---
title: 《深入理解计算机系统》
date: 2018-06-21 11:09:00
categories: 笔记
tags: 
    - Linux
toc: true
---

《深入理解计算机系统》阅读笔记。
<!-- more -->

1 计算机系统漫游
================

1.1 信息就是位+上下文
--------------------

从一个 Hello World 程序开始。

1.2 程序被其他程序翻译成不同的格式
------------------------------

![](http://static.ifanze.cn/059DE969-4B39-4DD9-90DD-D7A19456C064.jpeg)

1.3 了解编译系统如何工作是大有益处的
---------------------------------

- 优化程序性能。
- 理解链接错误。
- 避免安全漏洞。

1.4 处理器读并解释存储在内存中的指令
--------------------------------

shell 是一个命令行解释器。

### 1.4.1 系统的硬件组成

1. 总线

    - 携带信息字节并负责在各个部件间传递。
    - 通常设计成传送定长的字节块，也就是 **字（word）**。
    - 大多数机器字长要么是4字节（32位），要么是8字节（64位）。

2. I/O设备

    - 系统与外部世界的联系通道。
    - 每个I/O设备都通过 **控制器** 或者 **适配器** 与I/O总线相连。
    - 控制器是I/O设备本身或者系统的主印制电路板（主板）上的芯片组。
    - 适配器是一块插在主板上的卡。

3. 主存

    - 临时存储设备，处理器执行程序时，用来存放程序和程序处理的数据。
    - 物理上，由一组 **动态随机存取存储器（DRAM）** 芯片组成。
    - 逻辑上，是一个线性的字节数组，每个字节都有唯一的地址（从0开始）。

4. 处理器

    - CPU，解释（或执行）存储在主存中指令的引擎。
    - 核心是一个大小为一个字的存储设备（或寄存器），称为 **程序计数器（PC）**。
    - 任何时刻，PC都指向主存中的某条机器语言指令。
    - 处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由 **指令集架构** 决定的。
    - 指令所对应的简单操作并不多，它们围绕着 **主存**、**寄存器文件（register file）** 和 **算术/逻辑单元（ALU）** 进行。这些操作包括：
        - 加载。
        - 存储。
        - 操作。
        - 跳转。

    - 现代处理器使用了非常复杂的机制来加速程序的执行。注意区分：
        - **处理器的指令集架构**：每条机器代码指令的效果。
        - **处理器的微体系架构**：处理器实际是如何实现的。

### 1.4.2 运行Hello程序

1. shell将我们输入的`./hello`逐一读入寄存器，再把它放入内存。
2. 敲回车时，shell知道我们结束了命令的输入。shell将执行一系列指令来加载可执行的`hello`文件，将目标文件中的代码和数据从磁盘复制到主存。
    - 注：利用 直接存储器存取（DMA）技术，数据可以不通过处理器而字节从磁盘到达主存。
3. 处理器开始执行main中的机器语言指令，这些指令将字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。

1.5 高速缓存至关重要
-------------------

- 系统花费了大量时间把信息从一个地方挪到另一个地方。
- 根据机械原理，较大存储设备要比较小存储设备运行得慢，快速设备得造价远高于同类的低速设备。
- **高速缓存存储器（cache memory）**：作为暂时的集结区域，存放处理器近期可能会需要的信息。分为L1、L2、L3。

1.6 存储设备形成层次结构
---------------------

![](http://static.ifanze.cn/3DD2FD2F-67B1-4F21-A61B-5C13C9CD3ED5.jpeg)

1.7 操作系统管理硬件
------------------

- shell 和 hello 程序都没有直接访问键盘、显示器、磁盘、主存等硬件，而是依靠操作系统提供服务。
- 操作系统的两个基本功能：
    - 防止硬件被失控的应用程序滥用。
    - 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。
- 操作系统使用以下几个抽象概念来实现这两个基本功能：
    - **文件**：对I/O设备的抽象。
    - **虚拟内存**：对主存和磁盘I/O设备的抽象。
    - **进程**：对处理器、主存和I/O设备的抽象。

### 1.7.1 进程

- 操作系统为程序提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和I/O设备。
- **并发运行**：一个进程的指令和另一个进程的指令是交错执行的。
- **上下文**：操作系统保持跟踪进程运行所需的所有状态信息。
- **上下文切换**：操作系统把处理器的控制权从当前进程转移到某个新进程。它是由内核（kernel）管理的。
- **内核**：操作系统代码常驻内存的部分，不是一个独立的进程，时系统管理全部进程所用代码和数据结构的集合。
- 当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的 **系统调用（system call）** 指令，将控制权传递给内核，内核执行请求并返回应用程序。

### 1.7.2 线程

- 多线程比多进程更容易共享数据。
- 往往比进程更高效。

### 1.7.3 虚拟内存

- Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的。

![](http://static.ifanze.cn/6C8172FF-0CB9-42A7-BCD6-9388D1DAEB11.jpeg)

- 区：
    - **程序代码和数据**。代码从一个固定地址开始，紧接着C全局变量。是直接按照可执行目标文件的内容初始化的。
    - **堆**。
    - **共享库**。
    - **栈**。
    - **内核虚拟内存**。为内核保留，不允许应用程序读写或直接调用内核代码定义的函数，必须调用内核来执行这些操作。

### 1.7.4 文件

- 文件就是字节序列。
- 每个I/O设备，包括磁盘、键盘、显示器、网络，等可以看成文件。

1.8 系统之间利用网络通信
-----------------------

![](http://static.ifanze.cn/65C98DBF-964A-42AA-AA0D-D99FB6B74B92.jpeg)


1.9 重要主题
------------

### 1.9.1 Amdahl定律

- 思想：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。

> 若系统执行某应用程序需要时间为`T-old`，假设系统某部分所需执行时间与该时间的比例为`a`，而该部分性能提升比例为`k`。由此计算加速比：
> `S = T-old/T-new = 1 / ((1-a) + a/k)`

### 1.9.2 并发和并行

- **并发（concurrency）**：同时具有多个活动的系统。
- **并行（parallelism）**：用并发来使一个系统运行得更快。

并行可以用在计算机系统的多个抽象层次上：

1. 线程级并发

    - 单处理器系统。
    - 多处理系统。
        - 多核处理器。![](http://static.ifanze.cn/6CBC7CD7-5628-480C-A7FC-E9F9CF441ACA.jpeg)
        - 超线程（hyperthreading），或称同时多线程（simultaneous multi-threading）。允许一个CPU执行多个控制流，它涉及到CPU某些硬件有多个备份，如程序计数器、寄存器文件。

2. 指令级并行

    - 早期处理器，执行一条指令需要3~10个时钟周期。
    - 现在的处理器使用了许多聪明的技巧来同时处理多达100条指令。
    - **流水线（piplining）**：将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤，这些阶段可以并行地操作。
    - 如果处理器可以达到比一个周期一条指令更快地执行速率，就称之为 **超标量（super-scalar）处理器**。

3. 单指令、多数据并行（SIMD并行）

    - 在最低层次上，许多现代处理器拥有特殊地硬件，允许一条指令产生多个可以并行执行地操作。
    - 可以提高对影像、声音、视频数据地处理效率。
    - 有些编译器会试图从C程序中自动抽取SIMD并行性，但更好地方法是用编译器支持地特殊向量数据类型来写程序。

### 1.9.3 计算机系统中抽象的重要性

- 再增加一个抽象：虚拟机，是对整个计算机的抽象，包括操作系统、处理器和程序。

习题：
-----

- [x] 1.1 Amdahl定律公式的应用
- [x] 1.2 Amdahl定律公式的应用






2 信息的表示和处理
================

2.1 信息存储
-----------

- **字节（byte）**：最小的可寻址的内存单位。

### 2.1.1 十六进制表示法

- 二进制、十进制、十六进制间的相互转化。

### 2.1.2 字数据大小

- 每台计算机都有一个 **字长（word size）**，指明指针数据的标称大小（nominal size)。
- 虚拟地址是以这样的一个字来编码的，所有字长决定了虚拟地址空间的最大大小（`0 ~ 2^w-1`）。
- 32位字长：4GB。
- 64位字长：16EB。
- 32位程序和64位程序的区别在于如何编译的，大多数64位机器也可运行32位机器编译的程序（向后兼容）。

```shell
$ gcc -m32 prog.c
$ gcc -m64 prog.c
```

- C语言中：
    - 即使是64位系统编译，`int`通常也只有4字节。
    - C语言中，`long`在32位程序中为4字节，在64位程序中为8字节。
    - ISO C99 引入了确定大小的数据类型：`int32_t`、`int64_t`。
    - 除非有`unsigned`，类型默认是有符号的，`char`是个例外，C标准不保证这一点。

### 2.1.3 寻址和字节顺序

```c
int a = 0x01234567;

//                0x100   0x101   0x102   0x103
//大端法    ...     01      23      45      67      ...
//小端法    ...     67      45      23      01      ...
```

- 字节顺序很重要的场合：

    - 网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则。
    - 阅读表示整数数据的字节序列时。如反汇编器（disassembler）生成的代码。
    - 当编写规避正常的类型系统的程序时。如强制类型转换（cast）或使用联合（union）。

- 值相等的整数和浮点数在字节模式上截然不同，不过一般能够通过移位相匹配。

### 2.1.4 表示字符串

- 以`0`结尾的字符数组。
- 使用ASCII码作字符码将在任何系统上得到相同的结果，与字节顺序和字大小规则无关。

### 2.1.5 表示代码

- 二进制代码很少能在不同机器和操作系统组合之间移植。

### 2.1.6 布尔代数简介

- `~`
- `&`
- `|`
- `^`

### 2.1.7 C语言中的位级运算

- `~`
- `&`
- `|`
- `^`

### 2.1.8 C语言中的逻辑运算

- `&&`
- `||`
- `!`

### 2.1.9 C语言中的移位运算

- 左移：丢弃最高的k位，在右端补k个0。
- 逻辑右移：在左端补k个0。
- 算术右移：在左端补k个最高有效位的值。

- C语言标准并未明确定义有符号数使用哪种右移，但几乎所有的编译器/机器都使用算术右移。
- 如果移动k位，k超过了该数据类型的长度（w位），在许多机器上，将只考虑移位`log(2)w`位。
- 加减运算符优先级比移位运算符高。


2.2 整数表示
-----------

### 2.2.1 整型数据类型

- 典型的C语言有符号整数的正负值范围是不对称的，负数多1个。
- C语言标准定义的有符号整数类型必须能够表示的最小范围的正负值范围是对称的，除了`*32_t`、`*64_t`这种。

### 2.2.2 无符号数的编码

- 用函数`B2U-w`表示。
- 无符号编码的唯一性：该函数是个双射。

### 2.2.3 补码编码（Two's complement）

- 用函数`B2T-w`表示。
- 补码编码的唯一性：该函数是个双射。

有符号数的其他表示方法：

- 反码（Ones' Complement）
- 原码（Sign-Magnitude）

### 2.2.4 有符号数和无符号数之间的转换

- 用函数`T2U-w`、`U2T-w`表示。
- 对大多数C语言实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能改变，但位模式不变。
- 表现在最终数值上：
    - 有符号转无符号：正数不变，负数加`2^w`。
    - 无符号转有符号：范围内不变，范围外减`2^w`。

### 2.2.5 C语言中的有符号数与无符号数

- 无符号数添加后缀`u`。
- 显式类型转换。
- 隐式类型转换。
- 格式化输出。
- 运算数的转换：有符号和无符号运算，将转为无符号并假设二者都是非负的。
- C语言中`INT_MIN`往往定义成`-INT_MAX-1`。

### 2.2.6 扩展一个数字的位表示

- 无符号数的零扩展：添加0。
- 补码数的符号扩展：添加最高有效位的值。
- 如果即需要扩展有需要改变符号，C语言标准要求：先改变大小，再完成符号转换。

### 2.2.7 截断数值

- 截断无符号数：丢弃高位。新值为`x mod 2^k`。
- 截断补码数值：丢弃高位，重新解释符号位。新值为`U2T-k(x mod 2^k)`

### 2.2.8 关于有符号数与无符号数的建议

- 可以要求绝不使用无符号数。
- 如果仅仅想把数字作为位的集合，无符号数是非常有用的。

2.3 整数运算
------------

### 2.3.1 无符号加法

- `x+y`若溢出，最终结果相当于`x+y-2^w`。
- 判断`x+y`是否溢出的方法是与`x`或`y`进行比较。
- 无符号数取反，`-x`，最终结果相当于`2^w-x`。（`0`除外，依然是0）。

### 2.3.2 补码加法

- `x+y`若溢出，最终结果相当于`x+y-2^w`（正溢出）或`x+y+2^w`（负溢出）。
- 当且仅当`x>0, y>0, s<=0`时，发生了正溢出。
- 当且仅当`x<0, y<0, s>=0`时，发生了负溢出。

### 2.3.3 补码的非

- `-TMin-w`还是`TMin-W`。其他数正常。
- 补码非得位级计算方式一：`-x` -> `~x+1`。
- 补码非得位级计算方式二：找到最右边的1，将它左边的所有位取反。

### 2.3.4 无符号乘法

- `x*y`若溢出，最终结果相当于`x*y mod 2^w`。

### 2.3.5 补码乘法

- `x*y`若溢出，最终结果相当于`U2T-w(x*y mod 2^w)`。
- 无符号和补码乘法的位级等价性：同样的位向量，无论是做无符号乘法还是补码乘法，最终结果的位向量都是一样的。

### 2.3.6 乘以整数

- 乘以2的幂：左移。(无论是无符号还是补码，无论是否溢出)
- C语言编译器会试图用移位和加法替代乘法，如`x*14 = (x<<3) + (x<<2) + (x<<1);`，因为`14 = 2^3 + 2^2 + 2^1`，或者`x*14 = (x<<4) - (x<<1)`，因为`14 = 2^4 - 2^1`。

### 2.3.7 除以2的幂

- 整数的除法的结果总是向0舍入，即会向下舍入一个正值，或者向上舍入一个负值。
- 无符号：逻辑移位即可，即`x / 2^k = x >> k`，结果是向下舍入的。
- 补码：如果仅仅算术移位，对负数来说结果依然是向下舍入的。因此需要做点偏移：`x / 2^k = (x+(1<<k)-1) >> k`。

### 2.3.8 关于整数运算的最后思考

- 计算机的整数运算实际上是一种模运算形式。
- 结果运算可能溢出。
- 补码提供了一种既能表示整数又能表示负数的灵活方法。
- 某些规定和数据类型让程序产生意想不到的行为。


2.4 浮点数
-------------

- IEEE浮点标准。

### 2.4.1 二进制小数



习题：
-----

- [x] 2.1 二进制/十六进制转换。
- [x] 2.2 二进制/十进制/十六进制转换。
- [x] 2.3 二进制/十进制/十六进制转换。
- [x] 2.4 十六进制加减运算。
- [x] 2.5 整数的大小端存储。
- [x] 2.6 值相等的整数和浮点数在字节模式上的比较。
- [x] 2.7 字符串的字节模式。
- [x] 2.8 位向量的布尔运算。
- [x] 2.9 布尔运算与三原色。
- [x] 2.10 使用`^`实现两数交换。
- [x] 2.11 使用`^`交换同一地址的值时导致的问题。
- [x] 2.12 使用掩码提取或设置个别位上的状态。
- [ ] 2.13 使用“设置位”、“清除位”操作实现“或”和“异或”运算。
- [x] 2.14 布尔运算和逻辑运算。
- [x] 2.15 只使用位级和逻辑运算实现`x==y`。
- [x] 2.16 移位运算。
- [x] 2.17 无符号数的编码和补码编码。
- [x] 2.18 十六进制转补码转十进制。
- [ ] 2.19 有符号数转无符号数。
- [ ] 2.20 分析2.19。
- [ ] 2.21 有符号和无符号进行运算。
- [ ] 2.22 验证补码数的符号扩展规则。
- [ ] 2.23 移位和符号转换的综合运用。
- [ ] 2.24 截断数值。
- [ ] 2.25 有符号数和无符号数混用导致的错误。
- [ ] 2.26 有符号数和无符号数混用导致的错误。
- [ ] 2.27 判断两个无符号数相加是否溢出。
- [ ] 2.28 无符号数求反。
- [ ] 2.29 可能溢出的补码加法。
- [ ] 2.30 判断两个补码相加是否溢出。
- [ ] 2.31 判断两个补码相加是否溢出。
- [ ] 2.32 判断两个补码相加是否溢出。
- [ ] 2.33 补码的非。
- [ ] 2.34 无符号乘法和补码乘法。
- [ ] 2.35 判断乘法是否溢出。
- [ ] 2.36 判断乘法是否溢出。
- [ ] 2.37 修复XDR库乘法漏洞。
- [ ] 2.38 移位和加法替代乘法的应用。
- [ ] 2.39 移位和加法替代乘法的应用。
- [ ] 2.40 移位和加法替代乘法的应用。
- [ ] 2.41 移位和加法替代乘法的应用。
- [ ] 2.42 实现一个“除以16”的函数。
- [ ] 2.43 乘除综合练习。
- [ ] 2.44 整数运算综合练习。

3 程序的机器级结构
================

4 处理器体系结构
================

5 优化程序性能
=============

6 存储器层次结构
===============

7 链接
=======

8 异常控制流
============

9 虚拟内存
==========

10 系统级I/O
============

11 网络编程
==========

12 并发编程
==========