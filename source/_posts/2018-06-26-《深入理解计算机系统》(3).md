---
title: 《深入理解计算机系统》读书笔记 3
categories: 《深入理解计算机系统》
toc: true
comments: true
date: 2018-06-26 20:18:17
tags:
    - linux
    - 读书
---

《深入理解计算机系统》读书笔记 第三章 程序的机器级表示。

<!-- more -->
<!-- toc -->


3 程序的机器级结构
================

- 通过阅读汇编代码：

    - 理解编译器的优化能力，并分析代码中隐含的低效率。
    - 如用线程包写并发程序时，了解不同线程如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据。
    - 许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的控制权。


3.1 历史观点
-----------

Intel处理器俗称x86。主要发展历程：

- 8086（1978年）。第一代单芯片，16 位微处理器之一。其变种 8088 构成了最初 IBM 个人计算机的心脏，与微软开发了 MS-DOS 系统。
- 80286（1982年）。MS Windows 最初的使用平台。
- i386（1985年）。体系结构扩展到 32 位。Intel 系列中第一台全面支持 Unix 的机器。
- i486（1989年）。改善了性能，集成了浮点单元，但指令级没有明显改变。
- Pentium（1993年）。改善了性能。
- PentiumPro（1995年）。全新的处理器设计，P6 微体系结构。
- Pentium 4E（2004年）。增加了超线程（hyperthreading），使得可以在一个处理器上同时运行两个程序；还增加了 EM64T，是 Intel 对 AMD 提出的对 IA32 的 64 位 扩展的实现，我们称之为 x86-64。
- Core 2（2006年）。回归 P6。Intel 第一个多核微处理器，但不支持超线程。
- Core i7，Nehalem（2008年）。既支持超线程，也有多核。
- Core i7，Sandy Bridge（2011年）。引入了 AVX，这是对 SSE 的扩展，支持把数据封装进 256 位的向量。
- Core i7，Haswell（2013年）。将 AVX 扩展至 AVX2，增加了更多指令和指令格式。

这些处理器是后向兼容的：较早版本上编译的代码可以在较新的处理器上运行。

- IA32：Intel 32位体系结构（Intel Architecture 32-bit）。
- Intel64：IA32 的 64位扩展，也称为 x86-64。
- x86：指代整个系列。


3.2 程序编码
-----------

```bash
gcc -0g -o p p1.c p2.c
```

### 3.2.1 机器级编码

两种抽象：

- 指令集体系结构或指令级架构（Instruction Set Architecture, ISA）：定义机器级程序的格式和行为、处理器状态和指令的格式、每条指令对状态的影响。
- 机器级程序使用的内存地址是虚拟地址。

机器代码的一些在C语言中不可见的状态：

- 程序计数器（PC，x86-64中用%rip表示）：下一条指令在内存中的地址。
- 整数寄存器文件：包含16个命名的位置。
- 条件码寄存器：保存最近执行的算术或逻辑指令的状态信息，实现控制或数据流中的条件变化。
- 一组向量寄存器：存放一个或多个整数或浮点的值。

- 汇编代码不区分有符号无符号，不区分各种类型的指针，甚至不区分指针和整数。
- x86-64 的虚拟地址是由 64 位的字来表示的，在目前的实现中，高 16 位地址必须设置为 0。（64TB）

### 3.2.2 代码示例

查看编译器产生的汇编代码（生成`*.s`）：

```
gcc -0g -S *.c
```

编译并汇编代码（生成目标文件`*.o`）：

```
gcc -0g -c *.c
```

使用 gdb 展示程序的二进制目标代码：

```
# 先用反汇编器确定该函数的代码长度是14字节。
(gdb) x/14xb func1
```

利用反汇编器查看机器代码内容：

```
objdump -d mstore.o
```

一些关于机器代码和反汇编表示的特性：

- x86-64 的指令长度从 1 到 15 个字节不等。
- 设计指令格式的方式：从某个给定位置开始，可以将字节唯一地解码成机器指令。
- 反汇编器只基于代码文件中的字节序列来确定汇编代码，不需要访问源代码或汇编代码。
- 反汇编器使用的指令命名规则和 GCC 生成的汇编代码有些细微差别。如：省略了很多指令结尾的`q`，也给一些指令添加了`q`。

- 连接器会为函数调用找到匹配的函数的可执行代码的位置。
- 机器代码中在函数末尾处会填充字节使函数代码变为16字节，提升存储器系统性能。

### 3.2.3 关于格式的注解

- `.`开头的行都是指导汇编器和连接器工作的伪指令。
- ATT 汇编代码格式（GCC、Objdump等工具的默认格式）和 Intel 汇编代码格式（Microsft 的工具和 Intel 的文档）的区别：

    - Intel 代码省略了指示大小的后缀。如`q`。
    - Intel 代码省略了寄存器名字前面的`%`。
    - Intel 代码用不同的方式来描述内存中的位置。如`QWORD PTR [rbx]`而不是`(%rbx)`。
    - 多个操作数的指令下，列出的操作数顺序相反。

- C程序中插入汇编代码的方法：

    - 编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把他们合并。
    - 用 GCC 的内联汇编（inline assembly）特性，用 asm 伪指令在 C 程序中包含简短的汇编代码。

3.3 数据格式
------------

- 字节（byte）：8位。后缀`b`。
- 字（word）：16位。后缀`w`。
- 双字（DWORD）：32位。后缀`l`。
- 四字（QWORD）：64位。后缀`q`。

![](http://static.ifanze.cn/F5590D50-6424-408D-A53E-B7AD2FFAE876.jpeg)

- 单精度浮点：4字节。
- 双精度浮点：8字节。
- long double：10字节（不推荐）。

3.4 访问信息
-----------

- 8086：8个16位寄存器，从`%ax`到`%bp`。
- IA32：8个32位寄存器，从`%eax`到`%ebp`。
- x86-64：16个64位寄存器，从`%rax`到`%rbp%`，从`%r8`到`%r15`。

![](http://static.ifanze.cn/DB2A5541-5654-4FA4-B935-CD7FADB6DD4B.jpeg)

- 生成 1 字节和 2 字节数字的指令会保持剩下的字节不变。
- 生成 4 字节数字的指令会把高位 4 个字节置为 0。

### 3.4.1 操作数指示符

- 立即数（immediate），ATT 格式中，用`$`前缀加标准C表示法的整数。
- 寄存器（register）。
- 内存引用。有四个组成部分：立即数偏移、基址寄存器、变址寄存器、比例因子。

![](http://static.ifanze.cn/E5DD9AA6-0E23-4DF6-9C8E-3B7232B4B174.jpeg)

### 3.4.2 数据传送指令

#### `MOV` 指令类

指令             | 效果   | 描述
----------------|--------|------------
MOV  S, D       | D <- S | 传送
movb            |        | 传送字节
movw            |        | 传送字
movl            |        | 传送双字
movq            |        | 传送四字
movabsq  I, R  | R <- I | 传送绝对的四字

- 源操作数指定的值是一个立即数，存储在寄存器或内存中。
- 目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。
- x86-64 不允许两个操作数都指向内存地址。
- 寄存器部分的大小必须与指令后缀匹配。
- `movl`指令以寄存器作为目标时，会把高 4 位也置为 0。
- `movq`只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64 位的值，放到目的位置。
- `movabsq`能够以任意 64 位立即数作为源操作数，并且只能以寄存器作为目的。

#### `MOVZ` 指令类

- 将较小的源值复制到较大的目的时，用 0 填充。

指令             | 效果           | 描述
----------------|---------------|-----------------
MOVZ  S, R      | R <- 零扩展(S) | 以零扩展进行传送
movzbw          |               | 字节 -> 字
movzbl          |               | 字节 -> 双字
movzwl          |               | 字   -> 双字
movzbq          |               | 字节 -> 四字
movzwq          |               | 字   -> 四字

#### `MOVS` 指令类

- 将较小的源值复制到较大的目的时，用 符号扩展 填充。

指令             | 效果                 | 描述
----------------|----------------------|-----------------------
MOVS  S, R      | R <- 符号扩展(S)      | 以零扩展进行传送
movsbw          |                      | 字节 -> 字
movsbl          |                      | 字节 -> 双字
movswl          |                      | 字   -> 双字
movsbq          |                      | 字节 -> 四字
movswq          |                      | 字   -> 四字
movslq          |                      | 双字 -> 四字（`movzlq` 并不存在，因为用 `movl` 其实就能实现）
cltq            | %rax <- 符号扩展(%eax)| 把 %eax 符号扩展到 %rax（即 `movslq %eax,%rax`）

### 3.4.3 数据传送示例

- 函数的参数通过寄存器传递给函数。
- 函数通过把值存储在寄存器`%rax`或该寄存器某个低位部分中返回。
- 间接引用指针就是将该指针放在一个寄存器中。
- 局部变量通常是保存在寄存器中，而不是内存中。

### 3.4.4 压入和弹出栈数据

- 栈向下增长，栈顶元素的地址是栈中所有元素地址中最低的。
- `%rsp`保存着栈顶元素的地址。
- 程序可以用标准的内存寻址方法访问栈内的任意位置。

指令       | 效果                   | 描述
----------|------------------------|-------------
pushq  S  | R[%rsp] <- R[%rsp] - 8 | 将四字压入栈
          | M[R[%rsp]] <- S        |
popq  D   | D <- M[R[%rsp]]        | 将四字弹出栈
          | R[%rsp] <- R[%rsp] + 8 |


3.5 算数和逻辑操作
---------------

四组操作：

- 加载有效地址：

    - `leaq S,D`，效果：`D <- &S`

- 一元操作：

    - `INC D`：加 1。
    - `DEC D`：减 1。
    - `NEG D`：取负。
    - `NOT D`：取补。

- 二元操作：

    - `ADD S, D`：加。
    - `SUB S, D`：减。
    - `IMUL S, D`：乘。
    - `XOR S, D`：异或。
    - `OR S, D`：或。
    - `AND S, D`：与。

- 移位：

    - `SAL k, D`：左移。
    - `SHL k, D`：左移。
    - `SAR k, D`：算术右移。
    - `SHR k, D`：逻辑右移。

### 3.5.1 加载有效地址 
    
- `leaq`实际上是`movq`指令的变形。
- 形式是从内存读数据到寄存器，但实际上根本没有引用内存，只是将有效地址写入到目的操作数。
- 编译器经常发现`leaq`的一些灵活用法，比如可以简洁地描述普通的算术计算（加法和乘法），根本就与有效地址的计算无关。

### 3.5.2 一元和二元操作

- 一元操作：既是源又是目的。
- 二元操作：第二个操作数既是源又是目的，所以不能是立即数。如果第二个操作数是内存地址，处理器必须从内存读出值，执行操作，再把结果写回内存。

### 3.5.3 移位操作

- 第一个操作数：移位量。第二个操作数：要移位的数。
- 移位量可以是一个立即数，或者放在单字节寄存器`%cl`中。
- 移位操作对`w`位长的数据值进行操作时，移位量是由`%cl`寄存器的低`m`位决定的，这里`2^m = w`。高位被忽略。如`%cl`为`0xFF`：

    - `salb`移动 7 位。
    - `salw`移动 15 位。
    - `sall`移动 31 位。
    - `salq`移动 63 位。

### 3.5.4 讨论

- 除了右移操作，其他操作都无须区分有符号和无符号数。

### 3.5.5 特殊的算术操作

- 两个 64 位整数相乘的积需要 128 位来表示。x86-64 指令集对其提供了有限的支持：8字（oct word）。

指令       | 效果                                 | 描述
----------|--------------------------------------|-------------
imulq  S  | R[%rdx]: R[%rax] <- S*R[%rax]        | 有符号全乘法
mulq   S  | R[%rdx]: R[%rax] <- S*R[%rax]        | 无符号全乘法
clto      | R[%rdx]: R[%rax] <- 符号扩展(R[%rax]) | 转换为八字
idivq  S  | R[%rdx] <- R[%rdx]: R[%rax] mod S    | 有符号除法
          | R[%rdx] <- R[%rdx]: R[%rax] / S      |
divq   S  | R[%rdx] <- R[%rdx]: R[%rax] mod S    | 无符号除法
          | R[%rdx] <- R[%rdx]: R[%rax] / S      |

- `imulq`有两种形式：

    - 双操作数：两数相乘，产生一个64位乘积（截断，无符号乘和补码乘的位级行为是一样的，因此，没有`imulq`。）。
    - 单操作数：将`%rax`与操作数相乘，产生一个128位乘积，高位和低位分别存放在`%rdx`和`%rax`中。（`mulq`同理。）

- C 标准没有提供128位的值。可以借助 GCC 提供的`__int128`来声明128位整数。
- 将结果从寄存器取出时，要注意机器的大小端。

- `idivq`：

    - 将寄存器`%rdx`（高64位）和`%rax`（低64位）中的128位数作为被除数，操作数作为除数，商存放在`%rax`，余数存放在`%rdx`。
    - 除数应该放在`%rax`中，`%rdx`的位应该设置为0（无符号运算）或者`%rax`的符号位（有符号运算），使用`cqto`指令即可完成这个操作。
    - `divq`应该将`%rdx`事先设定为0。 


3.6 控制
--------

### 3.6.1 条件码（condition code）

除了整数寄存器，CPU 还维护着一组单个位的条件码寄存器。常用的条件码有：

- `CF`：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
- `ZF`：零标志。最近的操作得出的结果为 0。
- `SF`：符号标志。最近的操作得出的结果为负值。
- `OF`：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

除了`leaq`，上面列出的所有指令都会改变条件码。并且：

- 对于逻辑操作，如`XOR`，进位标志和溢出标志会设置成0。
- 对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置位0。
- `INC`和`DEC`指令会设置溢出和零标志，但是不会改变进位标志。

还有两类指令只设置条件码而不改变任何其他寄存器：

指令         | 基于    | 描述
------------|--------|------------
CMP  S1, S2 | S2 - S1 | 比较
 cmpb       |         | 比较字节
 cmpw       |         | 比较字
 cmpl       |         | 比较双字
 cmpq       |         | 比较四字
TEST S1, S2 | S1 & S2 | 测试
 testb      |         | 测试字节
 testw      |         | 测试字
 testl      |         | 测试双字
 testq      |         | 测试四字

- 在 ATT 格式中，列出操作数的顺序是相反的。
- 如果两个操作数相等：零标志置为 1。若不相等：根据其他标志判断。

### 3.6.2 访问条件码

- 根据条件码的某种组合，将一个字节设置为 0 或者 1。（`SET`指令。）
- 可以条件跳转到程序的某个其他的部分。
- 可以有条件地传送数据。

指令      |同义名    |效果                 |设置条件
---------|---------|--------------------|----------------
sete   D | setz    | D <- ZF            | 相等/零
setne  D | setnz   | D <- ~ZF           | 不等/非零
sets   D |         | D <- SF            | 负数
setns  D |         | D <- ~SF           | 非负数
setg   D | setnle  | D <- ~(SF^OF)&~ZF  | 大于（有符号）
setge  D | setnl   | D <- ~(SF^OF)      | 大于等于（有符号）
setl   D | setnge  | D <- SF^OF         | 小于（有符号）
setle  D | setng   | D <- (SF^OF) or ZF | 小于等于（有符号）
seta   D | setnbe  | D <- ~CF & ~ZF     | 超过（无符号）
setae  D | setnb   | D <- ~CF           | 超过或等于（无符号）
setb   D | setnae  | D <- CF            | 低于（无符号）
setbe  D | setna   | D <- CF or ZF      | 低于或等于（无符号）

- `SET`指令的后缀不是操作数的大小，而是不同的条件。
- `SET`的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置为 0 或者 1。因此如果要得到 32 位或者 64 位的结果，须对高位清零。

- 对于大多数情况，机器代码对于有符号和无符号两种情况都使用一样的指令。
- 有些情况需要用不同的指令来处理有符号和无符号操作。例如：右移、乘除、不同的条件码组合。

### 3.6.3 跳转指令

- `jmp`：无条件跳转指令。可以是：

    - 直接跳转：跳转目标是作为指令的一部分编码的。汇编中用标号，如`.L1`。
    - 间接跳转：跳转目标8是从寄存器或内存位置中读出的。汇编中用`*`跟操作数指示符，如`*%rax`、`*(%rax)`。

- 其他条件跳转都只能是直接跳转。

指令    |同义名  |跳转条件        |描述
-------|-------|---------------|----------------
je   D | jz    | ZF            | 相等/零
jne  D | jnz   | ~ZF           | 不等/非零
js   D |       | SF            | 负数
jns  D |       | ~SF           | 非负数
jg   D | jnle  | ~(SF^OF)&~ZF  | 大于（有符号）
jge  D | jnl   | ~(SF^OF)      | 大于等于（有符号）
jl   D | jnge  | SF^OF         | 小于（有符号）
jle  D | jng   | (SF^OF) or ZF | 小于等于（有符号）
ja   D | jnbe  | ~CF & ~ZF     | 超过（无符号）
jae  D | jnb   | ~CF           | 超过或等于（无符号）
jb   D | jnae  | CF            | 低于（无符号）
jbe  D | jna   | CF or ZF      | 低于或等于（无符号）

### 3.6.4 跳转指令的编码

跳转指令的编码分为：

- PC相对的（PC-relative）。将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为 1、2、4 个字节。程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。
- 绝对地址，用 4 个字节直接指定目标，汇编器和连接器会选择适当的跳转目的编码。

注：AMD 建议用`rep`后面跟`ret`的组合来避免使`ret`成为条件跳转指令的目标。如果没有`rep`，当分支不跳转时，`jg`指令会继续到`ret`指令。（以后遇到`rep`或`repz`就直接无视掉。）

3.7 过程
--------

3.8 数组分配和访问
-----------------

3.9 异数的数据结构
-----------------

3.10 在机器级程序中将控制与数据结合起来
----------------------------------

3.11 浮点代码
------------

3.12 小结
---------

习题
-----

- [x] 3.1 操作数的计算。
- [x] 3.2 `MOV`指令的选择。
- [x] 3.3 `MOV`指令的挑错。
- [x] 3.4 `MOV`、`MOVZ`、`MOVS`的计算，实现C语言强制类型转换的指令。
- [x] 3.5 `MOV`、`MOVZ`、`MOVS`的逆向推算。
- [x] 3.6 `leaq`的计算。
- [x] 3.7 `leaq`的逆向推算。
- [x] 3.8 一元和二元操作的计算。
- [x] 3.9 C语言移位运算的指令。
- [x] 3.10 算术操作的逆向推算。
- [x] 3.11 用`xorq %rdx, %rdx`实现赋 0 值。
- [x] 3.12 对比有符号除法和无符号除法产生的汇编。
- [x] 3.13 `SET`的逆向推算。
- [x] 3.14 `TEST`的逆向推算。

4 处理器体系结构
================

5 优化程序性能
=============

6 存储器层次结构
===============

7 链接
=======

8 异常控制流
============

9 虚拟内存
==========

10 系统级I/O
============

11 网络编程
==========

12 并发编程
==========