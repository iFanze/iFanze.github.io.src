---
title: 《C++ Primer》读书笔记
categories: 读书
toc: true
comments: true
date: 2018-06-23 15:13:19
tags:
    - 《C++ Primer》
---

One Sentence.

<!-- more -->
<!-- toc -->

# 第一章 开始

本章是一些基础知识，这里只做几点值得注意的：


## 1.1 最简单的C++程序

- main函数的返回类型必须为int。
- main函数的返回值在UNIX系统和Windows系统下分别可以使用以下命令获得：

```
$ echo $?
$ echo %ERRORLEVEL%
```

- GNU编译器是`g++`，Visual Studio的编译器是`cl`。使用示例：

```
$ g++ -o prog1 prog1.cc
C:\path\to\program> cl /EHsc prog1.cpp
```

- 这两种编译器打开警告信息分别使用`-Wall`和`/W4`。


## 1.2 初识输入输出

- `iostream`库中两个基础类型：`istream`、`ostream`。
- 标准输入输出对象：`std::cin`、`std::cout`、`std::cerr`、`std::clog`。
- 操纵符`std::endl`：结束当前行，并将设备关联的缓冲区中的内容刷到设备中。


## 1.3 注释简介

- //单行注释
- /* 多行注释 */

- 为避免多行注释的嵌套错误，最好用单行注释的方式注释掉代码段的每一行。


## 1.4 控制流

### 1.4.1 while和for

- 实现读取数量不定的输入数据：

```c
while (std::cin >> value)
    sum += value;
```

原理是：istream作为条件时，效果是检测流的状态是否有效，如果是有效的则为true，如果遇到文件结束符或无效输入则为false。

- 输入时，使用`Ctrl+Z`（Windows）或者`Ctrl+D`（UNIX）表示文件结束。

### 1.4.2 if

略。


## 1.5 类简介

作者引入了一个可以实现以下操作的`Sales_item`类：

- 调用`isbn()`获取书号。
- 使用`>>`和`<<`进行读写。
- 使用`=`进行同类型赋值。
- 使用`+`做加法，必须是同一本书，分别对销售额和销售数量求和。
- 使用`+=`做叠加赋值。


## 作者说

> 

# 第二章 变量和基本类型

## 2.1 基本内置类型

### 2.1.1 算术类型

- 包括**整型**和**浮点型**。
- C++标准规定的算术类型允许的最小尺寸（编译器实际可以赋予它们更大的尺寸）：

![](http://static.ifanze.cn/2018-06-23-14917411197717.jpg)

- `int`至少和`short`一样大。
- `long`至少和`int`一样大。
- `long long`至少和`long`一样大。（C++11）

- 字节`byte`：可寻址的最小内存块，通常是8 bits。一个字节要至少能容纳机器基本字符集中的字符。
- 字`word`：存储的基本单元，通常是32 bits或64 bits，即4 bytes或8 bytes。

- 计算机以比特序列存储数据，大多数计算机以2的整数次幂作为块来处理内存。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。

- `int`、`short`、`long`、`long long`区分带符号类型（signed）和无符号类型（unsigned）。
- `char`区分`char`、`signed char`和`unsigned char`三种。由具体编译器决定`char`属于另外两种中的哪一种，所以一般不要使用char进行算术运算。

- C++标准没有规定带符号类型应如何表示，但是约定了正负范围应该平衡。

使用建议：

1. 明确知道数值不可能为负值时，使用无符号。
2. 使用`int`执行整数运算。
3. 不适用`char`或`bool`进行算术运算。
4. 浮点运算使用`double`。它与`float`相比精度更高，计算代价相差无几甚至能更快，`long double`代价比较大。


### 2.1.2 类型转换

- 给无符号类型一个超过范围的值，将得到取模后的余数。
- 给带符号类型一个超过范围的值，结果是未定义的。

- 有符号数与无符号数一起运算，有符号数会先转化成无符号数。
- 无符号减去一个数，无论这个数是不是无符号，都必须确保结果不能是个负值。

- 切勿混用带符号类型和无符号类型。


### 2.1.3 字面值常量

- 十进制字面值是带符号的，具体类型是`int`、`long`、`long long`中能容纳的前提下尺寸最小的那个。
- 然而十进制字面值一般不会是负数，负号看作运算符。
- 八进制和十六进制不一定带符号。
- 若都容纳不下，会出现错误。

- 浮点型字面值是一个`double`，表示方法有：`3.14`、`3.14E0`、`0.`、`0e0`、`.001`。

- 字符字面值：`a`。
- 字符串字面值：`abc`。
- 字符串可以自动连接：

```c++
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;
```

- 转义序列：`\n`、`\t`、`\a`、`\v`、`\b`、`\"`、`\\`、`\?`、`\'`、`\r`、`\f`。
- 泛化的转义序列：`\x`+1个或多个十六进制数字，或者`\`+1~3个八进制数字。注意，前者会判定所有的数字，可能造成超过范围而报错，一般是配合扩展字符集使用的。后者最多只判定3个数字。

- 指定字面值类型的前缀和后缀：

![](http://static.ifanze.cn/2018-06-23-14917446771554.jpg)

- 字面值还包括`true`、`false`、`nullptr`。

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。

### 2.2.1 变量定义与初始化

```
int sum = 0, value,
    units_sold = 0;
Sales_item item;
std::string book("abcd");
```

- 本书不严格区分变量和对象，对象是一块能存储数据并具有某种类型的内存空间。
- 初始化和赋值是两个完全不同的操作。初始化是创建变量时赋予其一个初始值。赋值是把对象的当前值擦除，用一个新值替代。

- 初始化的几种形式：

```
int a = 0;
int a = {0};        // C++11
int a{0};           // C++11
int a(0);
```

- 列表初始化：如果会丢失精度，编译器会报错。

- 默认初始化：定义于任何函数体之外的变量被初始化为0；定义在函数体内的内置类型变量将不被初始化（值未定义）。
- 类的对象如果没有显式初始化，其值将取决于类。如`std::string`默认为空字符串。


### 2.2.2 变量声明和定义的关系

- C++支持分离式编译。
- 变量声明规定了变量的类型和名字。变量定义还申请了存储空间，也可能进行初始化。
- 变量声明的方式：使用`extern`，且不要显式初始化，否则就是定义了。并且如果在函数体内试图初始化一个extern变量，还会报错。
- 变量的定义必须出现在且只能出现在一个文件中。


### 2.2.3 标识符

![](http://static.ifanze.cn/2018-06-23-14917464771191.jpg)

### 2.2.4 名字的作用域

- 全局作用域：如`main`函数，声明后在整个程序的范围内都可使用。
- 块作用域：如`main`函数中定义的变量，从声明开始到函数结束为止都可以访问。
- 嵌套作用域：内层能访问外层的名字，也可以对该名字进行重新定义。如果重新定义后想获取全局作用域中声明的变量，可使用作用域操作符（全局作用域本身没有名字）：

```c++
std::cout << ::reused << std::endl;
```

- 建议：当你第一次使用变量时再定义它。

## 2.3 复合类型

### 2.3.1 引用

- 引用和初始值是绑定的，而不是对初始值的拷贝，且无法重新绑定，所以引用必须初始化。
- 引用即别名。赋值和取值使用的都是绑定的对象的值。
- 引用本身不是一个对象，因此不能定义引用的引用，也不能与字面值或表达式的计算结果相绑定。
- 除了两种例外情况，其它所有的引用的类型都要和与之绑定的对象类型严格匹配。（*2.4.1、15.2.3*）

### 2.3.2 指针

- 指针本身就是一个对象。
- 定义时无须赋初值，这样如果在块作用域内定义的话会拥有不确定的值。
- 获取某个对象的地址使用取地址符`&`，根据指针获取指向的对象使用解引用符`*`。
- 除了两种例外情况，指针类型也要和所指向的对象严格匹配。（*2.4.2、15.2.3*）
- 使用空指针：

```c++
int *p1 = nullptr;  // C++11，推荐
int *p2 = 0;
int *p3 = NULL;     // <cstdlib>，不推荐

int zero = 0;
pi = zero;          // 错误
```

- `void*`指针可以存放任意对象的地址，但是对对象的类型不了解。

### 2.3.3 理解复合类型的声明

- 一个语句中定义多个变量时要注意类型修饰符`*`和`&`不能省略：
- 指针和应用声明的两种写法：

```c++
int *p; 
int* p;
```

- 存在指向指针的指针，不存在指向引用的指针。
- 存在指针的引用：
 
```c++
int *p;
int *&r = p;    //从右向左阅读，最近的符号对变量的类型有最直接的影响。
```


## 2.4 const限定符

- const对象一旦创建后其值就不能再改变，所以它一定要初始化。
- 常量特征仅仅在执行改变该const变量时才会发挥作用。

如果多个文件共享一个const对象，即在一处定义，其余地方使用extern引用：

- 默认情况下，编译器必须知道该变量的初始值，并在编译过程中把用到该变量的地方都替换成对应的值。这就要求每个文件都必须得能访问到它的初始值才行。所以const对象被设定为仅在文件内有效，等同于在不同文件中分别定义了独立的变量。
- 如果不希望这样，即const变量初始值不是常量表达式，且希望在文件中共享，又不希望为每个文件生成独立的变量。可以在定义变量时也加上`extern`。

```c++
// file_1.cc
extern const int bufSize = fcn();
// file_1.h
extern const int bufSize;
```

### 2.4.1 const引用

- 对常量的引用：把引用绑定到const对象上，不能被用作修改它所绑定的对象。

```c++
const int ci = 1024;
const int &r1 = ci;     // 正确
r1 = 42;                // 错误
int &r2 = ci;           // 错误
```

- 引用类型可以与所引用对象的类型不同的一种例外情况：初始化常量引用时允许用任意表达式作初始值，只要表达式的结果能转换成引用类型。

```c++
int i = 42;
int &r1 = i * 2;            // 错误
const int &r2 = i * 2;      // 正确
```

- 常量引用可以引用非const的对象，这意味着虽然不能通过常量引用改变该对象的值，但还是可以通过其他方式对其修改的。

### 2.4.2 指针和const

- **指向常量的指针**：类似常量引用，不能被用作修改它所指向的对象的值。
- 使用指向常量的地址只能使用指向常量的指针。

```c++
const double pi = 3.14;
double *ptr = &pi;          // 错误
const double *cptr = &pi;   // 正确
```

- 指向常量的指针同样可以指向非const对象，同样意味着还是可以通过其他方式对该对象进行修改的。

- **常量指针**：因为指针是对象而引用不是，因此允许把指针本身定为常量，常量指针必须初始化。

```c++
int err = 0;
int *const curErr = &err;
const int *const constCurErr = &err;    // 记得从右向左阅读
```

### 2.4.3 顶层const

- **顶层const**：指针本身是一个常量。
- **底层const**：指针所指对象是一个常量。

当执行拷贝操作时：

- 顶层const不受什么影响。
- 底层const必须具有相同的底层const资格，或者能够转换（非常量可以转换成常量）。

```c++
int i = 0;
int *const p1 = &i;         // 顶层

const int ci = 42;          // 顶层
const int *p2 = &ci;        // 底层

const int *const p3 = p2;   // 底层  顶层

int *p = p3;                // 错误
int &r = ci;                // 错误
p2 = p3;                    // 正确，底层const资格一样，顶层不受影响
p2 = &i;                    // 正确，int *转换成const int*
```

- 总结：对指针，不能改变所指向对象的值的指针不能赋值给能改变指向对象的值的指针。

### 2.4.4 constexpr和常量表达式

- **常量表达式**：值不会改变并且在编译过程就能得到计算结果的表达式。

```c++
const int max = 20;         // max是常量表达式。
const int limit = max + 1;  // limit是常量表达式。
const int sz = get_size();  // sz不是常量表达式，因为在运行时才能确定值。
```

- 为了避免`const`修饰的常量在编译阶段不能确定值得情况，引入`constexpr`：

```c++
constexpr int mf = 20;
constexpr int sz = get_size();  // get_size()是一个constexpr函数时才正确。
```

- 声明为`constexpr`的对象类型不能太复杂，需要是显而易见、容易得到的，称为“字面值类型”。目前接触的类型中包括：算术类型、引用和指针。不包括自定义类、IO库、string。其它的字面值类型还有*7.5.6、19.3*。
- 定义为`constexpr`的指针初始值必须是`0`或`nullptr`或存储于固定地址的对象（*6.1.1*，函数体外的对象，或者函数体内定义的有效范围超过函数本身的变量）。

- 注意：

```c++
const int *p = nullptr;         // 指向整型常量的指针，底层const
constexpr int *q = nullptr;     // 指向整数的常量指针，相当于顶层const

int j = 0;                      // 函数体外定义
constexpr int i = 42;           // 函数体外定义

constexpr const int *p = &i;    // 指向整型常量的常量指针
constexpr int *p1 = &j;         // 指向整数j的常量指针
```

## 2.5 处理类型

### 2.5.1 类型别名

- 使用关键字`typedef`：

```c++
typedef double wages;
typedef wages base, *p;
```

- 使用别名声明：（C++11）

```c++
using SI = Sales_item;
```

注意：

```c++
typedef char *pstring;
const pstring cstr = 0;     // 指向char的常量指针
const char *cstr = 0;       // 指向const char的指针
```

### 2.5.2 auto类型说明符

- `auto`：让编译器根据初始值推算变量类型，所以必须初始化。
- 如果要在一个语句中声明多个变量，那么变量类型要相同。

```c++
auto sz = 0, pi = 3.14;     // 错误
```

- 如果使用引用，起作用的是引用对象的值。
- `auto`一般会忽略顶层const，除非使用`const auto`，而底层const会被保留下来。

```c++
int i = 0;
const int ci = i, &cr = ci;
auto b = ci;        // 相当于int
auto c = cr;        // 相当于int 
auto d = &i;        // 相当于int*
auto e = &ci;       // 相当于const int*
const auto f = ci;  // 相当于const int
```

- 如果要在一条语句中定义多个变量，要注意类型一致问题。

```c++
auto k = ci, &l = i;    // int
auto &m = ci, *p = &ci; // const int
auto &n = i, *p2 = &ci; // 错误，int 和 const int
```

### 2.5.3 decltype类型指示符

- 返回操作数的数据类型，如果表达式是函数调用，并不会真正调用这个函数。

```c++
decltype(f()) sum = x;
```

- 如果该表达式是个变量，和`auto`不同的是，它返回的类型是包括顶层const和引用在内的。所以在这里和通常情况不一样，引用并不能作为所指对象的同义词。

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;         // const int
decltype(cj) y = x;         // const int&，所以必须初始化。
```

- 如果该表达式不是变量，则返回表达式结果对应的类型。

```c++
int i = 42, *p = &i, &r = i;
decltype(r) a = i;          // int&，必须初始化
decltype(r + 0) b;          // int
decltype(*p) c = i;         // int&，解引用得到的类型是引用
```

- 如果表达式是个变量，加上括号就是表达式了，可能会改变最后的值的类型。（双层括号永远是引用）

```c++
decltype((i)) d;            // int&，所以错误，必须初始化
decltype(i) e;              // int 
```

## 2.6 自定义数据结构

### 2.6.1 定义Sales_data类型

```c++
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```

- 不推荐类的定义和对象的定义写在一起。
- 可以为数据成员提供一个类内初始值。没有初始值的成员将被默认初始化。
- 类内初始值和之前（*2.2.1*）介绍的一样，要么放在花括号中，要么放在等号后面，不能用圆括号。

### 2.6.2 使用Sales_data类型

略

### 2.6.3 编写自己的头文件

使用头文件保护符。

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
....
#endif
```

## 作者说

> 避免无法预知和依赖于实现环境的行为。

# 第三章 字符串、向量和数组

## 3.1 命名空间的using声明

- 头文件不应包含using声明，因为头文件的内容会拷贝到引用它的文件中。

## 3.2 标准库类型string

### 3.2.1 定义和初始化string对象

```c++
string s1;
string s2(s1);
string s2 = s1;             // 拷贝初始化
string s3("value");         // 直接初始化
string s3 = "value";
string s4(n, 'c');          // 直接初始化
string s4 = string(n, 'c'); // 非要用拷贝初始化，没有任何好处
```

### 3.2.2 string对象上的操作

![](http://static.ifanze.cn/2018-06-23-14918952018476.jpg)

- `cin >> s`会忽略掉开始和结束的空白符，返回`cin`。
- `getline()`读取到换行符并将它抛弃、不存储。
- `getline()`若一开始就读取到换行符则会得到空字符串。
- `size()`的返回类型是`string::size_type`。和其它标准库一样，这种配套类型体现了标准库类型与机器无关的特性，我们虽然不清楚这个类型的细节，但它一定是无符号的，且足够存下任何string类型的大小。（所以千万不要和负数比较。）
- 书写代码时，表示下标的整数类型可以声明为`auto`或者`decltype(str.size())`。
- 使用`+`时，可以把string和字符串字面值相加，但一定要保证每个`+`旁边至少有一个string对象。
- 切记字符串字面值和string是不同的类型。
- 无论何时用到下标，都要检查合法性。

### 3.2.3 处理string对象中的字符

![](http://static.ifanze.cn/2018-06-23-14918966526612.jpg)

```c++
string str("xxxxx");
for (auto c : str)
    cout << c;
for (auto &c : str)
    c = toupper(c);
```


## 3.3 标准库类型vector

- vector是模板而非类型，它能容纳绝大多数类型的对象作为其元素，但因引用不是对象，不存在包含引用的vector。
- 如果vector的元素还是vector，C++11之前要求在`>>`之间添加一个空格。

### 3.3.1 定义和初始化vector对象

![](http://static.ifanze.cn/2018-06-23-14918973664299.jpg)

- 初始化的两个vector对象类型必须相同。
- 使用拷贝初始化时，只能提供一个初始值。
- 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式。
- 值初始化：要么是内置类型，如int默认为0；要么类支持默认初始化，如string默认为空字符串。
- 注意区分使用`()`（表示构造）和`{}`（表示列表初始化）。

### 3.3.2 向vector对象中添加元素

- 使用`push_back()`。
- C++标准要求vector应该能在运行时高效快速地添加元素。
- 如果循环体内部含有向vector对象添加元素的语句，则不应使用for循环。

### 3.3.3 其它vector操作

![](http://static.ifanze.cn/2018-06-23-14918995026471.jpg)


## 3.4 迭代器介绍

### 3.4.1 使用迭代器

- 使用`begin()`和`end()`获取首迭代器和尾后迭代器。
- 二者相等则容器为空。
- 二者返回的迭代器类型是否带`const`取决于该对象是否是常量。
- C++引入两个新函数`cbegin()`、`cend()`方便获得`const_iterator`的迭代器。

![](http://static.ifanze.cn/2018-06-23-14918998046563.jpg)

- 并非所有容器都有下标运算符，与之类似，大多数迭代器没有定义`>`等符号。（我的理解：定义了下标运算符的容器，其相应的迭代器才能使用`>`等作比较。）
- `(*iter).mem`中的括号不能省。

**迭代器类型：**

```c++
vector<int>::iterator it1;          
vector<int>::const_iterator it2;        //只能读，不能写。
```

### 3.4.2 迭代器运算

![](http://static.ifanze.cn/2018-06-23-14919004596501.jpg)

- 其中，两个迭代器相减得到的类型是`difference_type`，vector和string中均有定义，它是有符号的。


## 3.5 数组

### 3.5.1 定义和初始化内置数组

- 默认情况下，数组中的元素执行默认初始化。所以函数内部定义的内置类型的数组会初始化为未定义值。
- 不能使用`auto`去推断数组类型，不能建立引用的数组。
- 使用列表初始化可以忽略掉数组的维度。
- 字符数组和字符串的关系。
- 不允许拷贝和赋值。

**复杂的数组声明：**

```c++
int *ptrs[10];                  // 含有10个int的数组
int &refs[10];                  // 错误
int (*Parray)[10];              // 指向一个含有10个int的数组
int (&arrRef)[10] = arr;        // 引用一个含有10个int的数组
int *(&arry)[10] = ptrs;
```

- 默认情况下，类型修饰符从右向左依次绑定。有括号的由内而外。

### 3.5.2 访问数组元素

- 数组下标是`<cstddef>`中定义的`size_t`类型，该类型是一种机器相关的无符号类型，被设计得足够大以便能表示内存中任意对象的大小。

### 3.5.3 指针和数组

- 大多数表达式中，数组名相当于指向首元素的指针。
- 指针相当于数组的迭代器。
- C++11引入`begin()`和`end()`用于获得数组的首元素指针和尾后指针。（`<iterator>`）

```c++
int ia[] = {0,1,2};
auto ia2(ia);                   // int*类型
decltype(ia) ia3 = {4,5,6};     // 含三个元素的数组类型

int *pbeg = begin(ia), *pend = end(ia);
while(pbeg != pend){
    ...
    ++pbeg;
}
```

- 两个指针相减的结果类型是`ptrdiff_t`，定义在`<cstddef>`，机器相关，有符号。
- 内置的下标运算符使用的索引值不是无符号类型，即可以为负数，这一点与vector、string等不一样。

### 3.5.4 C风格字符串

- 不安全，不推荐。

![](http://static.ifanze.cn/2018-06-23-14919027228249.jpg)

### 3.5.5 与旧代码的接口

- 需要用string的地方往往可以用C风格字符串替代。
- 需要用C风格字符串的地方不能直接用string替代，而是需要`str.c_str()`，返回类型是`const char*`，且在改变str后，这个值可能失去作用。
- 允许使用数组来初始化对象：

```c++
int int_arr[] = {1, 2, 3};
vector<int> ivec(begin(int_arr), end(int_arr));
```

## 3.6 多维数组

- 多维数组的初始化：

```c++
int a[3][4] = {
    {0, 1, 2, 3},
    {1, 2},
    {1}
};

int b[2][3] = {1, 2, 3, 4, 5, 6};
```

- 多维数组的遍历：

```c++
for(size_t i = 0; i != rowCnd; ++i)
    for(size_t j = 0; j != colCnt; ++j)
        ...
        
for(auto &row : ia)             // 一定是引用，否则auto是指针类型，内层就不能再用for了。
    for(auto &col : row)        
        ...
        
for(auto p = ia; p != ia + rowCnt; ++p)
    for(auto q = *p; q != *p + colCnt; ++q)
        ...
        
for(auto p = begin(ia); p != end(ia); ++p)
    for(auto q = begin(*p); q != end(*p); ++q)
        ...

```

- 指针和多维数组：

```c++
int ia[3][4];
int (*p)[4] = ia;       // p指向含有4个整数的数组
p = &ia[2];             // p指向ia的尾元素
```

- 使用类型别名简化多维数组的指针：

```c++
using int_array = int[4];
typedef int int_array[4];
for(int_array *p = ia; p != ia + 3; ++p) 
    for(int *q = *p; q != *p + 4; ++q)
        ...
```




# 第四章 表达式

## 4.1 基础

### 4.1.1 基本概念

- 一元运算符、二元运算符。
- 组合运算符、运算对象：注意优先级、结合律、求值顺序。
- 运算对象转换。
- 重载运算符。
- 左值：求值结果是一个对象或函数，但以常量对象为代表的某些左值实际上不能放在赋值语句左侧。
- 需要右值的地方可以用左值替代，反之则不行。

### 4.1.2 优先级与结合律

- 优先级：相对不同运算符而言。
- 结合律：相对相同运算符而言。
- 规定了运算对象的组合方式。

### 4.1.3 求值顺序

```c++
int i = f1() * f2();
```

- 我们只知道函数在乘法运算之前调用，但不知道谁先调用。

```c++
int i = 0;
cout << ++i << endl;
```

- 对没有指定求值顺序的运算符来说，如果表达式指向并修改了对象，它的结果是未定义的。
- 4种明确规定了求值顺序的运算：`&&`、`||`、`?:`、`,`。

## 4.2 算术运算符

![](http://static.ifanze.cn/2018-06-23-14919819824567.jpg)

- C++11规定商值一律向0取整（即直接去掉小数部分）。即`(-m)/n`、`m/(-n)`都等于`-(m/n)`。
- C++11规定取余的符号与被除数一样：`m%(-n)`等于`m%n`，`(-m)%n`等于`-(m%n)`。

## 4.3 逻辑与关系运算符

![](http://static.ifanze.cn/2018-06-23-14919824475818.jpg)

- 注意短路现象。

## 4.4 赋值运算符

- C++11允许使用花括号括起来的初始值列表作为赋值语句右侧运算对象。对内置类型，初始值列表最多只能包含一个值，且即使类型转化所占空间也不能大于目标类型的空间。对类类型，赋值运算细节由类本身决定。

```
int k;
k = {3.14}  // 错误，窄化转换
vector<int> vi;
vi = {1, 2, 3};
```

- 复合赋值运算符。

## 4.5 递增和递减运算符

- 除非必须，否则不用后置版本，因为会带来消耗，尤其是复制的迭代器。
- 后置常用在`*p++`上，让代码更简洁。
- 避免在表达式其它地方用到递增或递减的变量。

## 4.6 成员访问运算符

- 注意解引用运算符优先级低于点运算符，所以`(*p).size()`中括号不可省略。

## 4.7 条件运算符

- 条件运算符优先级非常低，记得使用括号。
- 可以嵌套使用，但会降低可读性。

## 4.8 位运算符

![](http://static.ifanze.cn/2018-06-23-14919840621288.jpg)


- 用于整数类型，把对象看作二进制位的集合。标准库类型`bitset`可以表示任意大小的二进制位集合，也可以使用。
- 一般小整型会被自动提升为较大整型，运算对象可以有符号，但对负数的运算依赖于机器，并且左移还可能改变符号位，所以推荐操作无符号数。


## 4.9 sizeof运算符

返回表达式或类型名所占的字节数，结果是`size_t`类型的常量表达式。有两种形式：

```c++
sizeof(type)
sizeof expr     // 返回表达式结果类型的大小，并不计算运算对象的值。
```

- 因为不计算，`sizeof *p`中，即便p是个无效的指针也没有问题。
- C++11中允许使用作用域运算符获得类成员的大小，如`sizeof Sales_data::revenue`。
- sizeof不会吧把数组转化成指针进行处理，得到的是数组所占字节数。
- 对容器使用只返回该类型固定部分的大小。

## 4.10 逗号表达式

- 左右先后执行，返回右侧的表达式结果。
- 常用在for循环。

## 4.11 类型转换

- 如果两种类型可以相互转换，那么它们就是关联的。
- 隐式转换。

### 4.11.1 算术转换

### 4.11.2 其它隐式类型转换

### 4.11.3 显式转换

```
cast-name<type> (expression);
```

cast-name：

- `dynamic_cast`：支持运行时类型识别。*19.2*
- `static_cast`：任何具有明确定义的类型转换，只要不包含底层const。
- `const_cast`：只能改变运算对象的底层const。去掉其const性质，让编译器不再阻止我们进行写操作。但如果对象是常量，写操作会造成未定义的结果。常用在函数重载中。*6.4*

```c++
const char *pc;
char *p = const_cast<char*>(pc);
```

- `reinterpret_cast`：从位的模式提供较低层次的重新解释。风险较大。

旧式转换：

```c++
type (expr);
(type) expr;
```

## 4.12 运算符优先级表
![](http://static.ifanze.cn/2018-06-23-14919859071475.jpg)
![](http://static.ifanze.cn/2018-06-23-14919859310420.jpg)



# 第六章 函数

6.1 函数基础
===========

- 编写和调用。
- 形参和实参。
- 形参列表和返回类型。

6.1.1 局部对象
-------------

- 自动对象。
- 局部静态对象：在程序执行路径第一次经过该对象的定义时初始化，直到程序终止才被销毁。

6.1.2 函数声明
-------------

- 函数的三要素：返回类型、函数名、形参类型。
- 函数原型：即函数声明。

6.1.3 分离式编译
---------------

- 在头文件中进行函数声明。

6.2 参数传递
===========

6.2.1 传值参数
-------------

6.2.2 传引用参数
---------------

6.2.3 const形参和实参
--------------------

和其他初始化过程一样，用实参初始化形参时会忽略掉顶层 const。

尽量使用常量引用。

6.2.4 数组形参
--------------

数组有两个性质：不允许拷贝，使用时会转换成指针。

几种传递数组长度信息的方法：

- C风格字符串使用标记位。
- 标准库规范，传两个指针。
- 再传递一个表示大小的参数。

可以使用数组引用形参，但这会限制数组的大小。

```c
void print(int (&arr) [10]);
```

传递多维数组：

```c
void print(int (*matrix)[10], int rowSize);
```

6.2.5 main: 处理命令行选项
-------------------------


6.2.6 含有可变形参的函数
---------------------

两种方式：

- 若类型相同，可使用 `initializer_list` 的标准库类型。
- 若类型不同，可编写一种特殊的函数，即可变参数模板。*16.4*

还有种使用省略符的方法，一般只用于与C函数交互的接口程序。

![](http://static.ifanze.cn/2018-06-23-15117024905657.jpg)

注意，实参要使用花括号的形式。




6.3 返回类型和 return 语句
=========================

6.3.1 无返回值函数
------------------


6.3.2 有返回值函数
-----------------

C++11中，函数可以返回花括号包围的值的列表。因为返回的值是用于初始化调用点的一个临时量。

```c++
vector<string> process()
{
    ...
    return {"xxx", "xxxx"};
}
```

主函数可以返回`<cstdlib>`里的`EXIT_FAILURE`或`EXIT_SUCCESS`。


6.3.3 返回数组的指针
-------------------

因为数组不能拷贝，所以函数不能返回数组。不过可以返回数组的指针或引用。有以下几种方法：

```c++
// 1. 使用类型别名
typedef int arrT[10];
arrT* func(int i);

// 2. 声明一个返回数组指针的函数
int (*func(int i))[10];

// 3. 使用尾置返回类型(C++11)
auto func(int i) -> int(*)[10];

// 4. 使用 decltype (C++11)
int odd[] = {1, 3, 5};
decltype(odd) *arrPtr(int i)
{
    ...
}
```

6.4 函数重载
============

有无顶层 const 形参无法区分开。

```
// 错误示例
Record lookup(Phone);
Record lookup(const Phone);

Record lookup(Phone*);
Record lookup(Phone* const);
```

底层 const 可以。

```
Record lookup(Account&);
Record lookup(const Account&);

Record lookup(Account*);
Record lookup(const Account*);
```

`const_cast`在重载场景下最有用：

```
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}

string& shorterString(string& s1, string& s2)
{
    auto &r = shorterString(const_cast<const string&>(s1),
    const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```

注意，所有重载函数的声明应放在同一作用域下。


6.5 特殊用途语言特性
===================

6.5.1 默认实参
------------

注意，声明时，每个形参只能被赋予一次默认实参，可以在不同声明中为不同形参添加默认实参。

默认形参的初始值可以是变量，但不能是局部变量，必须声明在函数之外，可以在调用前被别的函数所更改。

6.5.2 内联函数和 constexp 函数
-----------------------------

inline 只是向编译器发出了一个请求，编译器可以选择忽略这个请求。

constexp 函数的约定：

- 返回值及所有形参类型都是字面值类型。
- 函数题中必须有且只有一条 return 语句。

这两种函数可以在程序中多次定义，但是必须完全一致，因此通常定义在头文件中。

6.5.3 调试帮助
--------------

- assert 预处理宏：`<cassert>`中。
- NDEBUG 预处理变量：如果被定义，assert 将不起作用。


可以结合`#ifndef`进行调试。

编译器也定义了一些局部静态变量，可帮助调试：`__FILE__`、`__LINE__`、`__TIME__`、`__DATE__`。


6.6 函数匹配
===========

1. 确定候选函数。

    - 同名。
    - 可见。

2. 选出可行函数。

    - 参数数量相等（考虑默认值）。
    - 参数类型相同，或能转换。

3. 寻找最佳匹配。（如果有的话）

    - 逐一检查参数，寻找最匹配的。需要：
    
        - 每个参数的匹配都不劣于匹配其他函数。
        - 至少有一个参数的匹配优于匹配其他函数。

    - 如果并不是有且只有一个函数满足，编译器将报二义性调用的错误信息。

设计良好的系统中，不应该对实参进行强制类型转换。

实参类型转换的等级：

1. 精确匹配。

    - 类型相同。
    - 从数组或函数类型转成对应的指针类型。（*6.7*）
    - 添加或删除顶层 const。

2. 通过 const 转换实现的匹配。（*4.11.2*）
3. 通过类型提升实现的匹配。（*4.11.1*）
4. 通过算数类型转换或指针转换实现的匹配。（*4.11.1、4.11.2*）
5. 通过类类型转换实现的匹配。（*14.9*）    


6.7 函数指针
===========

```c++
// 1. 定义
bool (*pf)(const string&, const string&);

// 2. 赋值（&可选）
pf = 0;
pf = nullptr;
pf = lengthCompare;
pf = &lengthCompare;

// 3. 调用
pf("xx", "xx");
(*pf)("xx", "xx");

// 4. 函数指针形参
void useBigger(const string& s1, const string& s2, bool pf(const string &, const string &));
void useBigger(const string& s1, const string& s2, bool (*pf)(const string &, const string &));

// 5. 使用别名(*不能省略，不然是函数的别名)
typedef bool(*FuncP) (const string&, const string&);
typedef decltype(lengthCompare) *FuncP2;

// 6. 返回指向函数的指针((*)不能省略，不然是函数的别名)
using PF = int(*)(int*, int);
PF f1(int);
F *f1(int);     // *不能省略，返回值不能是函数。

int (*f1(int))(int*, int);  // 不用别名的写法。

decltype(sumLength) *getFcn(const string &);    // 使用 decltype 的写法，*不能省略。
```


如果指向重载函数，只能是符合它的那个。



# 第七章 类

7.1 定义抽象数据类型
==================

- 成员函数的定义。
- this 指针的理解。
- const 成员函数：意味着 this 是一个指向常量的指针，只能读取它的对象的数据成员，但是不能写入。
- 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。
- 合成的默认构造函数：
    - 如果存在类内的初始值，用它来初始化成员。
    - 否则，默认初始化该成员。
    - 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。
    - 如果声明了其他构造函数，有需要一个构造函数的默认行为，可以使用` = default`。
- 构造函数不应该轻易覆盖掉类内的初始值，除非新值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。

7.2 访问控制与封装
================
l
private 和 public。

7.2.1 友元
-----------


7.3 类的其他特性
===============

7.3.1 类成员再探
----------------

- 定义一个类型成员：使用 typedef 或 using，达到隐藏实现细节的作用。
- 可变数据成员：在成员变量的声明前使用`mutable`修饰，代表它永远不会是 const，即便在 const 函数中也能修改它。
- 当我们提供一个类内初始值时，必须以`=`或者花括号表示。

```c++
class Window_mgr{
private:
    std::vector<Screen> screens{Screen(24, 80, '')};
    int i = 0;
};
```

7.3.2 返回 *this 的成员函数
---------------------------

- 返回值用引用可实现连环调用，但对于返回常量引用的调用来说，这些还不够。
- 一种比较好的设计：

```
class Screen {
public:
    Screen &display(std::ostream &os)
    {
        do_display(os); 
        return *this;
    }
    const Screen &display(std::ostream &os) const
    {
        do_display(os); 
        return *this;
    }
private:
    void do_display(std::ostream &os) const
    {
        os << contents;
    }
};
```

7.3.3 类类型
------------

- 类可以做前向声明（forward declaration），在它声明之后定义之前是一个不完全类型（incomplete type），此时不能创建它的对象。
- 所以一个类的成员类型不能是它自己，但可以是它的引用或指针。

7.3.4 友元再探
-------------

- 可以声明友元类或友元类成员函数。
- 友元关系不存在传递性。
- 重载函数必须分别声明友元关系。
- 要想令某个成员函数作为友元，必须严格遵守以下顺序：

    1. 先定义 Window_mgr 类，其中声明 clear 函数，但不能定义它。
    2. 定义 Screen 类，包括对于 clear 的友元声明。
    3. 定义 clear。

- 声明友元函数不代表声明了该函数，该函数依然需要在类的外部进行声明，且在声明后才能被使用。（有的编译器并不强制执行该规则。）

7.4 类的作用域
==============

名字查找（name lookup）的一般过程：

    1. 在名字所在块中寻找声明，只考虑在名字使用之前出现的声明。
    2. 如果没有找到，继续查找外层作用域。
    3. 如果最终没有找到，程序报错。

对于定义在类内部的成员函数：

    1. 首先，编译成员的声明。
    2. 直到类全部可见后才编译函数体。

7.5 类的函数再探
===============

7.5.1 构造函数初始值列表
---------------------

- 初始化和构造函数里赋值的区别。
- 初始化顺序。
- 构造函数的默认实参。

7.5.2 委托构造函数
-----------------

C++11 允许构造函数把活交给别的构造函数干。


7.5.3 默认构造函数的作用
----------------------

使用默认构造函数不要加`()`，不然是定义了一个函数。

7.5.4 隐式的类类型转换
--------------------

如果构造函数只接受一个实参，则它实际上定义了一种类型的隐式转换机制，有时把它称之为转换构造函数（converting constructor）。

但是注意，只允许一步类类型转换。如 "xxxx" 转 sring 再转某 class 是非法的。除非显式地使用 `string("xxx")`进行转换。

想阻止这种转换，可将构造函数声明为`explicit`。它将只能以直接初始化的形式使用，而且，编译器将不会在自动转换过程中使用该构造函数（不能再使用`=`将参数类型的对象用于拷贝形式的初始化过程）。

但依然可以用显式转化实现。如`static_cast<Sales_data>(xxx)`或`Sales_data(xxx)`。

在标准库中：

    - 接受 const char * 的 string 构造函数不是 explicit 的。
    - 接受一个容器参数的 vector 构造函数是 explicit 的。

7.5.5 聚合类
-----------

聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。需要满足以下条件：

- 所有成员都是 public 的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，没有 virtual 函数。

可以提供一个花括号括起来的成员初始值列表，用它来初始化聚合类数据成员，顺序必须一致。

这种类缺点也较为明显：

- 要求所有成员 public。
- 用户决定初始化。
- 更改成员后修改代价大。

7.5.6 字面值常量类
-----------------

数据成员都是字面值类型的聚合类是字面值常量类。或者满足以下条件也是：

- 数据成员都必须是字面值类型。
- 类必须至少含有一个 constexpr 构造函数。
- 若数据成员含有初始值，则该值必须是一条常量表达式。如果该成员属于某类类型，初始值必须使用成员自己的 constexpr 构造函数。
- 必须使用析构函数的默认定义。

7.6 类的静态成员
===============

- 既可使用类名，也可使用对象访问静态成员。
- 在类的外部定义静态成员时，不能重复 static 关键字。
- 由于静态成员并不是在创建类的对象时被定义的，所以一般不能在类内进行初始化。（除了返回值是常量表达式的情况。）
- 和其他对象一样，一个静态数据成员只能定义一次，最好与其他非内联函数的定义放在同一个文件中。
- 即使一个常量静态数据成员在类内部被初始化了，通常也应在类的外部定义一下该成员。

- 由于静态成员独立于任何对象，所以有些特性：可以是不完全类型，可以就是它所属类的类型，可以用作默认实参。这些非静态成员都不可以。



# 第八章 IO库

8.1 IO 类
==========
![](http://static.ifanze.cn/2018-06-23-15122337573935.jpg)

ifstring 和 istringstream 都集成自 istream。

8.1.1 IO 对象无拷贝或赋值
------------------------

不能拷贝或赋值。
流类型不能作为函数返回类型。
传递和返回的引用不能是 const 的。

8.1.2 条件状态
-------------

![](http://static.ifanze.cn/2018-06-23-15122340445778.jpg)

![](http://static.ifanze.cn/2018-06-23-15122340524000.jpg)


8.2 文件输入输出
===============

- `ifstream`：从文件读数据，继承自`istream`。
- `ofstream`：从文件写数据，继承自`ostream`。
- `fstream`：从文件读写数据。

![](http://static.ifanze.cn/2018-06-23-15122809025479.jpg)

8.2.1 使用文件流对象
------------------

open() 失败会将 failbit 置位。

```c++
ofstream out;
out.open("xxx");
if (out)
    ...
```

记得关闭后再打开其他文件，离开作用域析构时会自动调用`close()`。

8.2.2 文件模式
--------------

![](http://static.ifanze.cn/2018-06-23-15122819839857.jpg)

- 只可以对 ofstream 或 fstream 对象设定 out 模式。
- 只可以对 ifstream 或 fstream 对象设定 in 模式。
- 只有当 out 也被设定时才可设定 trunc 模式。
- 只要 trunc 没被设定，就可以设定 app 模式。app 模式总是以输出方式被打开。
- 默认情况下，out 模式会有 trunc 效果，所以追加请同时指定 app，或者 in。
- ate 和 binary 可任意组合。

8.3 string 流
===============

- `istringstream`
- `ostringstream`
- `stringstream`

![](http://static.ifanze.cn/2018-06-23-15122823729187.jpg)

# 第九章 顺序容器

9.1 顺序容器概述
===============

![](http://static.ifanze.cn/2018-06-23-15122827443766.jpg)

选用原则：

- 除非有更好的理由，否则应用 vector。
- 如果元素小而多，空间开销很重要，不要用 list 或 forward_list。
- 要求随机访问：vector、deque。
- 在中间插入删除：list、forward_list。
- 在头尾插入删除：deque。

9.2 容器库概览
=============

本节介绍对所有容器都适用的操作。

![](http://static.ifanze.cn/2018-06-23-15122850635998.jpg)
![](http://static.ifanze.cn/2018-06-23-15122850769038.jpg)

9.2.1 迭代器
------------

9.2.2 容器类型成员
-----------------

9.2.3 begin 和 end 成员
-----------------------

9.2.4 容器定义和初始化
--------------------

![](http://static.ifanze.cn/2018-06-23-15122854553092.jpg)

将一个容器初始化为另一个容器的拷贝：

- 拷贝整个容器：容器类型和元素类型必须都匹配。
- 拷贝一对迭代器指定的范围：只需要元素类型匹配，甚至是可转换。

定义 array 容器不但要指定元素类型，还要制定容器大小：

```c++
array<string, 10>
```

如果元素类型是类类型，则它必须有一个默认构造函数，以使值初始化能够进行。

9.2.5 赋值和 swap
----------------

array 允许赋值，但类型和大小必须相同，且不允许用花括号包围的值列表进行赋值。

![](http://static.ifanze.cn/2018-06-23-15122861450508.jpg)

assign 不用保证容器类型要相同，只需元素类型相容即可。

除 array 外，swap 不对任何元素进行拷贝、删除、插入操作，保证在常数时间完成，只是交换了两个容器的内部数据结构。因此指向容器的迭代器、引用、指针都不会失效（除 string）。

统一使用非成员版本的 swap 是一个好习惯。（泛型编程很重要）

9.2.6 容器大小操作
----------------

size()、empty()、max_size()

9.2.7 关系运算符
---------------

==、!=、>、>=、<、<=


9.3 顺序容器操作
===============

9.3.1 向顺序容器添加元素
----------------------

![](http://static.ifanze.cn/2018-06-23-15122872873379.jpg)

emplace 是构造而不是拷贝元素。其参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。

9.3.2 访问元素
--------------

![](http://static.ifanze.cn/2018-06-23-15122876911112.jpg)

下标访问若是越界，[]报运行时错误，at 抛出 out_of_range 异常。

9.3.3 删除元素
--------------

![](http://static.ifanze.cn/2018-06-23-15122878427283.jpg)

9.3.4 特殊的 forward_list 操作
------------------------------

![](http://static.ifanze.cn/2018-06-23-15122880697822.jpg)

核心思想：单向列表的添加删除，影响的是其前驱元素。所以，如果是遍历过程中进行添加或删除，往往要关注两个迭代器：

```c++
forward_list<int> flst = {0,1,2,3,4};
auto prev = flst.before_begin();
auto curr = flst.begin();
while (curr != flst.end()){
    if (*curr % 2)
        curr = flst.erase_after(prev);
    else{
        prev = curr;
        ++curr;
    }
}
```

9.3.5 改变容器大小
-----------------

![](http://static.ifanze.cn/2018-06-23-15122883564813.jpg)

9.3.6 容器操作可能使迭代器失效
---------------------------

9.4 vector 对象是如何增长的
=========================

vector 和 string 一定是连续的，空间不够了会移动所有元素。

![](http://static.ifanze.cn/2018-06-23-15122902887066.jpg)

reserve 不改变元素的数量，且永远也不会减少容器占用的内存空间。
resize 只改变容器中的元素数目。

9.5 额外的 string 操作
=====================

9.5.1 构造 string 的其他方法
---------------------------

![](http://static.ifanze.cn/2018-06-23-15122905813562.jpg)

![](http://static.ifanze.cn/2018-06-23-15122906238886.jpg)


9.5.2 改变 string 的其他方法
---------------------------

- 额外的 insert、erase 版本，在指定位置插入指定数量的指定字符。
- 接受 C 风格字符数组的 insert 和 assign 版本。
- append、replace。

![](http://static.ifanze.cn/2018-06-23-15122908256116.jpg)
![](http://static.ifanze.cn/2018-06-23-15122908459896.jpg)

9.5.3 string 搜索操作
--------------------

![](http://static.ifanze.cn/2018-06-23-15122909135162.jpg)
![](http://static.ifanze.cn/2018-06-23-15122909191619.jpg)

9.5.4 compare 函数
------------------

![](http://static.ifanze.cn/2018-06-23-15122909573903.jpg)

9.5.5 数值转换
--------------
![](http://static.ifanze.cn/2018-06-23-15122910145159.jpg)

9.6 容器适配器
=============

stack、queue、priority_queue。

![](http://static.ifanze.cn/2018-06-23-15122915101195.jpg)

定义一个适配器：

- 默认情况下，stack 和 queue 是基于 deque 实现的，priority_queue 是在 vector 之上实现的。

```c++
stack<int> std(deq);
stack<string, vector<string>> str_stk;
stack<string, vector<string>> str_stk2(svec);
```

所有适配器都要求容器具有添加、删除、访问尾元素的能力，所以不能使用 array、forward_list。剩下的：

- 都可用于构造 stack，因为它只要求 push_back、pop_back、back。
- 只有 list 或 deque 能构造 queue，因为它要求 back、push_back、front、push_front。
- 只有 vector 或 deque 能构造 priority_queue，因为它要求 front、push_back、pop_back、随机访问。

![](http://static.ifanze.cn/2018-06-23-15122920763028.jpg)

![](http://static.ifanze.cn/2018-06-23-15122921377197.jpg)
![](http://static.ifanze.cn/2018-06-23-15122921500473.jpg)


# 第十章 泛型算法

10.1 概述
=========

- 定义在`<algorithm>`、`<numeric>`。
- 泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，一般不会改变底层容器的大小。

10.2 初识泛型算法
================

10.2.1 只读算法
---------------

find、count、accumulate、equal。

其中，accumulate 是累加，第三个参数是初始值，需要支持 `+` 运算。equal 操作两个序列，比较指定范围内的元素是否都相等。

```c++
string sum = accumulate(v.cbegin(), v.cend(), string(""));  // 不能改成""
```

10.2.2 写容器元素的算法
---------------------

注意确保序列原大小至少不小于我们要求写入的元素数目。

操作两个序列时，有些接受三个迭代器，有些接受四个。

`fill`函数：在指定位置之间填充指定值。
`fill_n`函数：从指定位置开始填充指定数量的指定值。注意空间够不够。
`copy`函数：
`replace`函数：
`replace_copy`函数：

插入迭代器：向插入迭代器所指元素赋值将插入新值。

```c++
vector<int> vec;
fill_n(vec.begin(), 10, 0);         // 错误
fill_n(back_inserter(vec), 10, 0);  // 正确

replace(ilst.begin(), ilst.end(), 0, 42);
replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);
```

10.2.3 重排容器元素的算法
-----------------------

- `sort`函数：排列。
- `unique`函数：排列使不重复的元素出现在前面，返回第一个出现重复的元素的位置。（标准库算法是对迭代器而不是容器进行操作。）


10.3 定制操作
============

10.3.1 向算法传递函数
-------------------

给 sort 等函数多传递一个参数，称作谓词（predicate）：它是一个可调用的表达式，其返回结果是一个能用作条件的值。

稳定排序：`stable_sort`。

10.3.2 lambda 表达式
---------------------

`find_if`函数：第三个参数是一个谓词，返回第一个使谓词返回 true 的元素，否则返回尾迭代器。

可调用对象包括：

- 函数
- 函数指针
- 重载了函数调用运算符的类
- lambda 表达式

```
[capture list](parameter list) -> return type { function body }
```

其中，捕获列表是一个 lambda 所在函数中定义的局部变量的列表（通常为空）。我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。

如果函数体包含任何单一 return 语句之外的内容，且未指定返回类型，则返回 void。

```c++
auto f = [] { return 42; };
stable_sort(words.begin(), words.end(), [](const string& a, const string& b) { return a.size() < b.size(); } );
```

如果 lambda 表达式还用到它所在函数中的局部非静态变量，必须将它写在捕获列表中。所以 find_if 可以写成：

```c++
auto wc = find_if(words.begin(), words.end(),
            [sz] (const string &a)
                { return a.size() >= sz; });
```

`for_each`算法：接受一个可调用对象，对输入序列中每个元素调用此对象。


```c++
for_each(wc, words.end(), [](const string& s){cout << s << " ";});
```

10.3.3 lambda 捕获和返回
------------------------

变量的捕获方式也可以是值或引用。被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝。

```c++
size_t v1 = 42;
auto f = [v1] { return v1; };
v1 = 0;
auto j = f();       // j 为 42
```

以引用方式捕获：

```c++
size_t v1 = 42;
auto f = [&v1] { return v1; };
v1 = 0;
auto j = f();       // j 为 0
```

引用捕获和返回引用一样，要确保被引用对象在 lambda 执行的时候是存在的。

当我们向一个函数传递一个 lambda 时，lambda 会立即执行。

我们也可以返回一个 lambda，但注意不能包含引用捕获。

尽量减少捕获的数据量，尽量避免捕获指针或引用。

可以使用`&`或`=`表示隐式捕获，也可以混用隐式捕获和显式捕获。

```c++
[=]{const string &s) { return s.size() >= sz; });
[=, &os](const string &s) { os << s << c; });
```

![](http://static.ifanze.cn/2018-06-23-15124918050273.jpg)

如果希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。

```c++
size_t v1 = 42;
auto f = [v1] () mutable { return ++i; };
v1 = 0;
auto j = f();   // j 为 43
```

`transform`算法：将一个序列的元素依次做一个转化，放到另一个指定位置开始的序列中。

```c++
transform(vi.begin(), vi.end(), vi.begin(),
            [](int i) -> int
            { if ( i < 0 ) return -i; else return i; });
```

10.3.4 参数绑定
--------------

lambda 表达式适合使用次数少、代码少的应用场景，取代函数。但是不能直接把捕获列表作为谓词的参数放到函数的形参中。

解决方法：使用`<functional>`中定义的`bind`函数。

```c++
using std::placeholders::_1;
bool check_size(const string &s, string::size_type sz)
{
    return s.size() >= sz;
}
auto wc = find_if(words.begin(), words.end(),
                bind(check_size, _1, sz));
```

其中，`_1`是占位符。更一般的：

```c++
auto g = bind(f, a, b, _2, c, _1);

g(X, Y);
f(a, b, Y, c, X);
```

如果需要绑定引用，使用`ref`或`cref`函数：

```c++
for_each(words.begin(), words.end(),
            bind(print, ref(os), _1, ' '));
```

旧版本的 bind1st 和 bind2nd 应被弃用。

10.4 再探迭代器
==============

<iterator> 中还定义了：

- 插入迭代器。
- 流迭代器。
- 反向迭代器。
- 移动迭代器。

10.4.1 插入迭代器
-----------------

![](http://static.ifanze.cn/2018-06-23-15124937743666.jpg)

三种类型：

- `back_inserter`：创建一个使用 push_back 的迭代器。
- `front_inserter`：创建一个使用 push_front 的迭代器。
- `inserter`：创建一个使用 inserter 的迭代器，此函数接受第二个参数表示位置，元素被插入到它之前。


```c++
*it = val;
//inserter 插入迭代器相当于：
it = c.insert(it, val);     // 指向新加入的元素
++it;                       // 指回原来的元素


list<int> lst = {1,2,3,4};
list<int> lst2, lst3;
copy(lst.cbegin(), lst.cend(), front_inserter(list2));  // 4,3,2,1，始终指向新首元素。
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));   // 1,2,3,4
```

10.4.2 iostream 迭代器
-----------------------

- `istream_iterator`要读写的类型必须定义了`>>`。
- `ostream_iterator`要读写的类型必须定义了`<<`。

```c++
// 构造1：使用流
istream_iterator<int> int_it(cin);
ifstream in("afile");
istream_iterator<string> str_it(in);

// 构造2：默认初始化
istream_iterator<int> int_eof;          // 可得到尾后迭代器，一旦到文件尾或者IO错误，迭代器就与之相等。

// 用法1: 从流中读内容
while (int_it != int_eof)
    ivec.push_back(*in_it++);

// 用法2: 两个迭代器结合用来构造容器
istream_iterator<int> in_iter(cin), eof;
vector<int> vec(in_iter, eof);

// 用法3：算法中使用
istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << endl;
```

![](http://static.ifanze.cn/2018-06-23-15126478937848.jpg)

注意：标准库不保证迭代器立即从流读取数据，允许使用懒惰求值，只保证在第一次解引用前完成从流中读数据的操作。


```c++
ostream_iterator<int> out_iter(cout, " ");
// 用法1：
for (auto e : vec)
    out_iter = e;   // 等效于 *out_iter++ = e;，但推荐别简写。
    
// 用法2：
copy(vec.begin(), vec.end(), out_iter);
```

10.4.3 反向迭代器
----------------

- `rbegin`、`rend`、`crbegin`、`crend`。
- 反响迭代器需要`--`运算符。
- 可以调用`base()`转化成正常迭代器。

![](http://static.ifanze.cn/2018-06-23-15126482760762.jpg)


10.5 泛型算法结构
=================

10.5.1 5类迭代器
----------------

![](http://static.ifanze.cn/2018-06-23-15126484658475.jpg)

10.5.2 算法形参模式
-----------------

```c++
alg(beg, end, ...);
alg(beg, end, dest, ...);
alg(beg, end, beg2, ...);
alg(beg, end, beg2, end2, ...);
```

10.5.3 算法命名规范
------------------

重载一个谓词：

```c++
unique(beg, end);
unique(beg, end, comp);
```

_if 版本：

```c++
find(beg, end, val);
find_if(beg, end, pred);
```

区分拷贝不拷贝的版本：

```c++
reverse(beg, end);
reverse_copy(beg, end, dest);
```

同时包含上面两点：

```c++
remove_if(beg, end, pred);
remove_copy_if(beg, end, dest, pred);
```


10.6 特定容器算法
================

list 和 forward_list 还定义了：

![](http://static.ifanze.cn/2018-06-23-15126493120661.jpg)
![](http://static.ifanze.cn/2018-06-23-15126493216728.jpg)

通用版本的 sort 要求随机访问迭代器，不能用于它们。list 和 forward_list 应优先使用成员函数版本的算法。

另外还有`splice`成员：
![](http://static.ifanze.cn/2018-06-23-15126493931751.jpg)

有些链表版本的算法与通用版本有区别，主要是会改变底层结构。包括`remove`、`unique`、`merge`、`splice`。


# 第十一章 关联容器

2 * 2 * 2 = 8种：

- `set`、`map`
- `multi`：允许重复关键字（定义在`<map>`、`<set>`）
- `unordered`：无序保存（定义在`unordered_map`、`unordered_set`）


11.1 使用关联容器
================

基本使用。

11.2 关联容器概述
================

11.2.1 定义关联容器
------------------

11.2.2 关键字类型的要求
--------------------

有序容器需要关键字类型支持**行为正常**的比较操作。

```c++
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() < rhs.isbn();
}

multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);    // 后面的 compareIsbn 可以换成 &compareIsbn
```

注意：用 decltype 来获得一个函数指针类型时，必须加上一个`*`指出我们要得到的是函数的指针。


11.2.3 pair 类型
----------------

在`<utility>`中。

![](http://static.ifanze.cn/2018-06-23-15126508707740.jpg)

如果函数返回 pair：

```c++
pair<string, int> process(vector<string> &v)
{
    if(...)
        return {v.back(), v.back().size()};     // 列表初始化（C++11）
    else
        return pair<string, int>();             // 隐式构造返回值
}
```

还可以使用：

```c++
return pair<string, int>(v.back(), v.back().size());
return make_pair(v.back(), v.back().size());
```

11.3 关联容器操作
================

![](http://static.ifanze.cn/2018-06-23-15126510682571.jpg)

11.3.1 关联容器迭代器
-------------------

- 关键字类型（包括 pair 的 first）是 const 的。
- 对 map 解引用得到的类型是 value_type，是个 pair。
- set 的 iterator 和 const_iterator 都是只读的，不能改变 set 的元素。
- 通常不对关联容器使用泛型算法，关键字是 const 这一特性使得算法不能对容器进行修改或重排。关联容器可用于只读算法，如 find，但还是优先使用成员函数版本。
- 实际使用中，若是用在泛型算法上，要么当作一个源序列，要么当作一个目标位置（使用 inserter）。

11.3.2 添加元素
---------------

```c++
set1.insert(ivec.cbegin(), ivec.cend());
set1.insert({1, 2, 3});
map1.insert({word, 1});
map1.insert(make_pair(word, 1));
map1.insert(pair<string, size_t>(word, 1));
map1.insert(map<string, size_t>::value_type(word, 1));
```

![](http://static.ifanze.cn/2018-06-23-15126518693490.jpg)

对于不返回重复关键字的容器，这些函数返回一个 pair，其 first 是一个迭代器，指向具有给定关键字的元素；second 成员是一个 bool 值，指出是插入成功还是已经存在于容器。

一个单词计数的例子：

```c++
map<string, size_t> word_count;
string word;
while (cin >> word){
    auto ret = word_count.insert({word, 1});
    if (!ret.second)
        ++ret.first->second;
}
```

auto 的类型是：

```
pair<map<string, size_t>::iterator, bool>
```

注意，对于`mutiset`和`multimap`，一定会插入成功，因此只返回迭代器。

11.3.3 删除元素
--------------

![](http://static.ifanze.cn/2018-06-23-15128849829768.jpg)

11.3.4 map 的下标操作
--------------------

如果关键字不在 map vs ,下标运算符会创建一个元素并插入到 map 中，并进行值初始化。所以，我们只能对非 const 的 map 使用下标操作。

![](http://static.ifanze.cn/2018-06-23-15128851559984.jpg)

注意在 map 中，下标操作的返回值和对迭代器进行解引用不一样。前者是 mapped_type，后者是 value_type。但相同的一点是都是左值。

11.3.5 访问元素
---------------
![](http://static.ifanze.cn/2018-06-23-15128852997668.jpg)

注意：lower_bound 和 upper_bound 不适用于无序容器。下标和 at 只适用于非 const 的 map 和 unordered_map。

不能用下标运算符来检查一个元素是否存在！

如果是在 multimap 或 multiset 查找给定关键字，有三种方法（它们一定是连续存储的）：

1. find 和 count：

```c++
auto count = map1.count(key);
auto iter  = map1.find (key);
while(count){
    count << iter->second << endl;
    ++iter;
    --count;
}
```

2. 迭代器组：

```c++
for (auto beg = map1.lower_bound(key),
          end = map1.upper_bound(key);
     beg != end;
     ++beg)
     cout << beg->second << endl;
```

3. equal_range函数

```c++
for (auto pos = map1.equal_range(key);
     pos.first != pos.second;
     ++pos.first)
     cout << pos.first->second << endl;
```

11.3.6 一个单词转换的 map
-----------------------

11.4 无序容器
=============

无序容器使用一个哈希函数将元素映射到桶。
![](http://static.ifanze.cn/2018-06-23-15128859821311.jpg)

无序容器对关键字类型使用`==`比较元素，还使用`hash<key_type>`类型的对象来生成每个元素的哈希值。标准库为内置类型，还有string和智能指针等标准库类型定义了hash。

但是，我们不能定义关键字类型为自定义类类型的无序容器。必须提供自己的 hash 模版。*16.5*


```c++
size_t hasher(const Sales_data &sd)
{
    return hash<string>()(sd.isbn());
}

bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn();
}

using SD_multiset = unordered_multiset<Sales_data, decltype(haser)*, decltype(eqOp)* >;

SD_multiset bookstore(42, hasher, eqOp);

// 如果已经定义了 == 运算符，则只重载哈希函数：
unordered_set<Foo, decltype(FooHash)* > fooSet(10, FooHash);
```




# 第十二章 动态内存

12.1 动态内存与智能指针
=====================

`<memory>`：`shared_ptr`、`unique_ptr`、`weak_ptr`。

12.1.1 shared_ptr 类
--------------------

![](http://static.ifanze.cn/2018-06-23-15128867730807.jpg)

```c++
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<int> p4 = new int(1024); // 错误，explicit。
```

递增引用计数：

- 使用它初始化另一个 shared_ptr。
- 作为参数传递给一个参数。
- 作为函数的返回值。
- ...

递减引用计数：

- 赋予一个新值
- shared_ptr 被销毁（如离开局部作用域）

如果计数器变为0，它就会自动释放自己所管理的对象。

使用动态内存的目的：

- 程序不知道自己需要使用多少对象。（容器类）
- 程序不知道所需对象的准确类型。（*15章*）
- 程序需要在多个对象间共享数据。

12.1.2 直接管理内存
------------------

使用`new (nothrow)`阻止抛异常。

容易出错的地方：

- 忘记 delete。
- 使用已经释放掉的对象。
- 同一块内存释放两次。

所以应坚持使用智能指针！

12.1.3 shared_ptr 和 new 结合使用
---------------------------------

```c++
shared_ptr<int> p4 = new int(1024); // 错误，explicit。
shared_ptr<int> p5(new int(1024)); // 正确
```

![](http://static.ifanze.cn/2018-06-23-15128912627452.jpg)
![](http://static.ifanze.cn/2018-06-23-15128912698568.jpg)

依然推荐用 make_shared，而不是混用。

get 函数的存在是为了去调用只支持内置指针的函数，且函数中不能 delete 此指针。不要用 get 初始化另一个智能指针或为另一个智能指针赋值。

reset 和 unique 一起使用：改变底层对象之前，检查自己是否是对象仅有的用户，若不是，改变前制造一份新的拷贝。

```c++
if (!p.unique())
    p.reset(new string(*p));
*p += newVal;
```

12.1.4 智能指针和异常
--------------------

使用智能指针能保证即便程序抛了异常也能销毁局部对象。

自定义删除器（deleter）来使 C 风格的代码也有析构函数的特性。

```c++
void end_connection(connection *p) { disconnect(*p); }

void f (...){
    connection c = connect(...);
    shared_ptr<connection> p(&c, end_connection);
    // 使用连接
    // 当 f 退出（即便出于异常），connection也会被正确关闭。
}
```

智能指针的使用基本规范：

- 不使用相同的内置指针初始化（或 reset）多个智能指针。
- 不 delete get() 返回的指针。
- 不使用 get() 初始化或 reset 另一个智能指针。
- 如果你使用 get() 返回的指针，记住当最后一个对应的智能指针销毁后，指针就变为无效了。
- 如果你使用智能指针管理的资源不是 new 分配的内存，记住传递给它一个删除器。

12.1.5 unique_ptr
-------------------

某个时刻只能有一个 unique_ptr 指向一个给定对象，所以不能拷贝和赋值。

![](http://static.ifanze.cn/2018-06-23-15128928379952.jpg)

但是可以使用`release`或`reset`进行转移：

```c++
unique_ptr<string> p1(new string("xxx"));
unique_ptr<string> p2(p1.release());
unique_ptr<string> p3(new string("Tex"));
p2.reset(p3.release());
p2.release();       // 错误：不释放内存却丢失了指针，release 一般用来初始化或赋值给另一个指针。
p2.reset();
```

不能拷贝 unique_ptr 的规则有个例外：将要被销毁的 unique_ptr，如作为函数返回值。

标准库的较早版本使用了一个名为`auto_ptr`的类，它具有`unique_ptr`的部分特性，但不是全部，如不能在容器中保存也不能从函数返回，因此，弃用。

传递删除器的版本：

```c++
unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection);
```

12.1.6 weak_ptr
----------------

![](http://static.ifanze.cn/2018-06-23-15128935571390.jpg)

不参与计数的 shared_ptr。不能直接使用它访问对象，而必须调用 lock。

```c++
if (shared_ptr<int> np = wp.lock()){
    ...
}
```

12.2 动态数组
=============

12.2.1 new 和数组
-----------------

`new[]`和`delete[]`。


标准库提供了一个可以管理 new 分配的数组的 unique_ptr 版本。

![](http://static.ifanze.cn/2018-06-23-15128943618508.jpg)

```c++
unique_ptr<int[]> up(new int[10]);
for (size_t i = 0; i != 10; ++i)
    up[i] = i;
up.release();
```

但是 shared_ptr 不能直接管理动态数组，需要删除器。

```c++
shared_ptr<int> sp(new int[10], [](int *p){ delete[] p; });
for (size_t i = 0; i != 10; ++i)
    *(sp.get() + i) = i;    // shared_ptr 未定义下标运算符，也不支持算术运算。
sp.reset();
```

12.2.2 allocator 类
-------------------

定义在`<memory>`，帮助我们将内存分配和对象构造分离开来，分配未构造的内存。

![](http://static.ifanze.cn/2018-06-23-15128950213473.jpg)

```c++
allocator<string> alloc;
auto const p = alloc.allocate(n);
auto q = p;
alloc.construct(q++);
alloc.construct(q++, 10, 'c');
alloc.construct(q++, "hi");
while (q != p)
    alloc.destroy(--q);
alloc.deallocate(p, n);
```

![](http://static.ifanze.cn/2018-06-23-15128956404634.jpg)

这些伴随函数返回（递增后的）目的位置迭代器。

12.3 使用标准库：文本查询程序
=========================

# 第十三章 拷贝控制

拷贝控制操作（copy control）：

- 拷贝构造函数（copy constructor）
- 拷贝赋值运算符（copy-assignment operator）
- 移动构造函数（move constructor）
- 移动赋值运算符（move-assignment operator）
- 析构函数（destructor）

13.1 拷贝、赋值与销毁
===================

13.1.1 拷贝构造函数
-----------------

第一个参数是自身类型的引用（且几乎总是`const`、不是`explicit`的），任何额外参数都有默认值。

如未定义，会有合成版本（即使定义了其他构造函数），依次拷贝类的非静态成员，包括数组。

```c++
string dots(10, '.');               // 直接初始化
string s(dots);                     // 直接初始化
string s2 = dots;                   // 拷贝初始化
string null_book = "9-999-9999";    // 拷贝初始化
string nines = string(100, '9');    // 拷贝初始化
```

拷贝初始化也可能是由移动构造函数完成。

拷贝初始化时机：

- 使用`=`定义对象。
- 将一个对象作为实参传递给一个非引用类型的形参。
- 返回一个对象（非引用）。
- 列表初始化一个数组中的元素或一个聚合类中的成员。
- 类中对所分配对象执行拷贝初始化操作。如 STL 中的`insert`等。

注意拷贝构造函数是不是`explicit`的，如：

```c++
vector<int> v1(10);     // 正确
vector<int> v2 = 10;    // 错误
```

编译器可能绕过拷贝/移动构造函数，而直接创建对象。（但拷贝/移动构造函数依然需要是存在且可访问的）

13.1.2 拷贝赋值运算符
-------------------

如果未定义，会有合成版本，会将右侧运算对象的每个非静态成员赋予左侧运算对象的相应成员，包括数组。

赋值运算符通常应该返回一个指向其左侧运算对象的引用。

13.1.3 析构函数
--------------

调用时机：

- 离开作用域。
- 当对象被销毁时，其成员被销毁。
- 容器被销毁时，其元素被销毁。
- 动态分配的对象，使用`delete`进行销毁。
- 对于临时对象，当创建它的完整表达式结束时被销毁。

13.1.4 三/五法则
---------------

- 需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符。
- 需要拷贝操作的类也需要赋值操作，反之亦然。

13.1.5 使用 = default
---------------------

显式要求编译器生成合成的版本，只能对编译器可以合成的默认构造函数或拷贝控制成员使用。

在类内使用将声明为内联的，如果不希望这样，应只在类外定义使用。

13.1.6 阻止拷贝
---------------

使用`= delete`，必须出现在第一次声明的时候，可以对任何函数使用，除了析构函数（会造成不能释放这些对象）。

合成的拷贝控制成员可能是删除的：

- 合成析构函数：当某成员的析构函数是删除的或者不可访问的。
- 合成拷贝构造函数：当某成员的拷贝构造函数或析构函数是删除的或者不可访问的。
- 合成拷贝赋值运算符：当某个成员的拷贝赋值运算符是删除的或不可访问的，或类的成员中有`const`或引用。
- 默认构造函数：当某个成员的析构函数是删除的或者不可访问的，或类的成员中有没有类内初始化器的`const`或引用。

使用`private`阻止拷贝的缺点是：友元和成员函数依然能够拷贝。对此可以只声明不定义，这样在试图拷贝时会报链接错误。

13.2 拷贝控制和资源管理
=====================

（实例）

13.3 交换操作
============

```c++
inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

注意这里调用的是`swap`，而不是`std::swap`，是想让在用户版本和 std 版本中自动匹配合适的函数。

有了交换操作后，可以用它更简单的定义赋值运算符，即拷贝并交换（copy and swap）。它是异常安全的，且能正确处理自赋值。

```c++
HasPtr& HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);
    return *this;
}
```


13.4 拷贝控制示例
===============

（实例）


13.5 动态内存管理类
=================

（实例）

引出移动。


13.6 对象移动
=============

很多情况会发生对象拷贝，某些时候对象拷贝后就立刻被销毁了。使用移动可以大幅度提升性能。

13.6.1 右值引用
--------------

- 只能绑定到一个将要销毁的对象（往往意味着也没有其他用户）。
- 变量是左值，不能将右值引用直接绑定到一个变量上，即使这个变量是右值引用类型。

可以使用`<utility>`中的`std::move`将一个左值显式地转换为对应的右值引用类型。告诉编译器：我有一个左值，但我希望像一个右值一样处理它，承诺不再使用它的值，除了对其赋值和销毁，因为移后源对象（moved-from）依然是一个有效的、可析构的状态，但不能对它的值做任何假设。

13.6.2 移动构造函数和移动赋值运算符
--------------------------------

类似拷贝构造函数，只是第一个参数是右值引用类型。

注意确保移动后的对象处在销毁它是无害的的状态，如将指针置为`nullptr`。

移动构造函数一般是`noexcept`的，由于它窃取资源而不分配资源。该关键字写在定义和声明的参数列表后，分号和冒号前。声明和定义都必须指定。

如果容器的元素是我们的自定义类型，如果不告诉编译器我们的移动构造函数是`noexcept`的，在进行一些操作时，如对`vector`进行需要增大内存分配的`push_back`操作，容器会不敢使用移动构造函数而是使用拷贝构造函数，因为它需要对异常发生时自身的行为提供保障：当异常发生时，vector 自身不会发生变化。



移动赋值运算符与析构函数和移动构造函数执行相同的工作。与移动构造函数一样，如果不抛异常就该标记为`noexcept`。

与拷贝不同，编译器根本不会为某些类合成移动操作。特别是当一个类定义了自己的拷贝函数、拷贝赋值运算符或者析构函数。没有移动构造函数后，根据正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，才会合成。

可以移动的成员包括：内置类型可以移动，有移动操作的类类型成员也能移动。

与拷贝不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们使用`=default`，且编译器不能移动所有成员，它会是删除的。例外是：

（一二三四，我选择不依赖合成而是自己定义= =）

定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。

如果一个类既有移动构造函数，也有拷贝构造函数。则移动右值，拷贝左值。但如果没有移动构造函数，右值也被拷贝。


引入移动操作后，*13.3*中的拷贝并交换赋值运算符在定义了移动构造函数之后会兼容移动操作。单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。


更新三/五法则：所有五个拷贝控制成员应该看作一个整体：如果定义了任何一个拷贝操作，就应该定义五个。这些类通常拥有一个资源。


移动迭代器：通过解引用得到返回一个指向元素的右值引用。使用`make_move_iterator`函数。例子：

```c++
auto first = alloc.allocate(newcapacity);
auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);
```


13.6.3 右值引用和成员函数
-----------------------

如果一个成员函数同时提供拷贝和移动版本，则一般使用与拷贝/移动构造函数和赋值运算符相同的参数模式：一个版本接受一个指向`const`的左值引用，一个版本接受一个指向非`const`的右值引用。

一般来说，我们不需要为函数操作定义接受一个`const X&&`或一个普通的`X&`参数的版本。


通常，我们在一个对象上调用成员函数，而不管对象是一个左值还是一个右值：

```c++
string s1= "xxxx", s2="xxxx";
auto n = (s1 + s2).find('a');
s1 + s2 = "wow!";
```

在旧标准中，我们没法阻止这种使用方式，为了向后兼容性，新标准依然允许。但是有方法进行阻止：限定`this`的左值/右值属性，像限制其`const`属性那样在参数列表后放置`&`或`&&`。如果需要同时放置`const`，`const`在前。需要同时在声明和定义中指定。

重载方式：

```c++
class Foo{
public:
    Foo sorted() &&;            // 可用于可改变的右值
    Foo sorted() const &;       // 可用于任何类型的 Foo
private:
    ...
};
```

注意：定义`const`成员函数时，可以定义两个版本：差别是有没有`const`。但引用限定的函数不一样，必须对所有函数都加上引用限定符，或者所有都不加。





